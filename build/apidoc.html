<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/OptimalBits/bull#readme"

    >bull (v2.2.6)</a>
</h1>
<h4>Job manager</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull">module bull</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.bull">
            function <span class="apidocSignatureSpan"></span>bull
            <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job">
            function <span class="apidocSignatureSpan">bull.</span>job
            <span class="apidocSignatureSpan">(queue, data, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue">
            function <span class="apidocSignatureSpan">bull.</span>priority_queue
            <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue">
            function <span class="apidocSignatureSpan">bull.</span>queue
            <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.super_">
            function <span class="apidocSignatureSpan">bull.</span>super_
            <span class="apidocSignatureSpan">(pubClient, subClient)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.timer_manager">
            function <span class="apidocSignatureSpan">bull.</span>timer_manager
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bull.</span>job.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bull.</span>priority_queue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bull.</span>queue.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bull.</span>scripts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bull.</span>super_.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bull.</span>timer_manager.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.job">module bull.job</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.job">
            function <span class="apidocSignatureSpan">bull.</span>job
            <span class="apidocSignatureSpan">(queue, data, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.create">
            function <span class="apidocSignatureSpan">bull.job.</span>create
            <span class="apidocSignatureSpan">(queue, data, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.fromData">
            function <span class="apidocSignatureSpan">bull.job.</span>fromData
            <span class="apidocSignatureSpan">(queue, jobId, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.fromId">
            function <span class="apidocSignatureSpan">bull.job.</span>fromId
            <span class="apidocSignatureSpan">(queue, jobId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.fromJSON">
            function <span class="apidocSignatureSpan">bull.job.</span>fromJSON
            <span class="apidocSignatureSpan">(queue, json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.job.prototype">module bull.job.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype._getBackOff">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>_getBackOff
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype._isDone">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>_isDone
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype._isInList">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>_isInList
            <span class="apidocSignatureSpan">(list)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype._moveToSet">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>_moveToSet
            <span class="apidocSignatureSpan">(set, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype._retryAtOnce">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>_retryAtOnce
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype._saveAttempt">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>_saveAttempt
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.delayIfNeeded">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>delayIfNeeded
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.discard">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>discard
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.finished">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>finished
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.getState">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>getState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.isActive">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>isActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.isCompleted">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>isCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.isDelayed">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>isDelayed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.isFailed">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>isFailed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.isPaused">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>isPaused
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.isStuck">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>isStuck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.isWaiting">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>isWaiting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.lockKey">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>lockKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.move">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>move
            <span class="apidocSignatureSpan">(src, target, returnValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.moveToCompleted">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>moveToCompleted
            <span class="apidocSignatureSpan">(returnValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.moveToDelayed">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>moveToDelayed
            <span class="apidocSignatureSpan">(timestamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.moveToFailed">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>moveToFailed
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.progress">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>progress
            <span class="apidocSignatureSpan">(progress)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.promote">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>promote
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.releaseLock">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>releaseLock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.remove">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>remove
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.renewLock">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>renewLock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.retry">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>retry
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.takeLock">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>takeLock
            <span class="apidocSignatureSpan">(renew, ensureActive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.toData">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>toData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.job.prototype.toJSON">
            function <span class="apidocSignatureSpan">bull.job.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.priority_queue">module bull.priority_queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.priority_queue">
            function <span class="apidocSignatureSpan">bull.</span>priority_queue
            <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.genericGetter">
            function <span class="apidocSignatureSpan">bull.priority_queue.</span>genericGetter
            <span class="apidocSignatureSpan">(fnName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.getQueueName">
            function <span class="apidocSignatureSpan">bull.priority_queue.</span>getQueueName
            <span class="apidocSignatureSpan">(name, priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.super_">
            function <span class="apidocSignatureSpan">bull.priority_queue.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bull.priority_queue.</span>priorities</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.priority_queue.prototype">module bull.priority_queue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.add">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>add
            <span class="apidocSignatureSpan">(data, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.clean">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>clean
            <span class="apidocSignatureSpan">(grace, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.close">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>close
            <span class="apidocSignatureSpan">( doNotWaitJobs )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.count">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>count
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.disconnect">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.empty">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.getActive">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.getCompleted">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.getDelayed">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getDelayed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.getFailed">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getFailed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.getQueue">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getQueue
            <span class="apidocSignatureSpan">(priority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.getWaiting">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getWaiting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.pause">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>pause
            <span class="apidocSignatureSpan">(localOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.process">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>process
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.resume">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>resume
            <span class="apidocSignatureSpan">(localOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.run">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>run
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.priority_queue.prototype.setLockRenewTime">
            function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>setLockRenewTime
            <span class="apidocSignatureSpan">(lockRenewTime)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>waitAfterEmptyLoop</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.queue">module bull.queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.queue">
            function <span class="apidocSignatureSpan">bull.</span>queue
            <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.super_">
            function <span class="apidocSignatureSpan">bull.queue.</span>super_
            <span class="apidocSignatureSpan">(pubClient, subClient)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.queue.prototype">module bull.queue.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.add">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>add
            <span class="apidocSignatureSpan">(data, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.clean">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>clean
            <span class="apidocSignatureSpan">(grace, type, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.close">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>close
            <span class="apidocSignatureSpan">( doNotWaitJobs )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.count">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>count
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.disconnect">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.distEmit">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>distEmit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.empty">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getActive">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getActiveCount">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getActiveCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getCompleted">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getCompleted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getCompletedCount">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getCompletedCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getDelayed">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getDelayed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getDelayedCount">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getDelayedCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getFailed">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getFailed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getFailedCount">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getFailedCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getJob">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJob
            <span class="apidocSignatureSpan">(jobId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getJobCountByTypes">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobCountByTypes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getJobCounts">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobCounts
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getJobMoveCount">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobMoveCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getJobs">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobs
            <span class="apidocSignatureSpan">(queueType, type, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getNextJob">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getNextJob
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getPausedCount">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getPausedCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getWaiting">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getWaiting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.getWaitingCount">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getWaitingCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.isReady">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>isReady
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.moveJob">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>moveJob
            <span class="apidocSignatureSpan">(src, dst, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.moveUnlockedJobsToWait">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>moveUnlockedJobsToWait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.multi">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>multi
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.on">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.once">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.pause">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>pause
            <span class="apidocSignatureSpan">(isLocal, doNotWaitActive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.process">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>process
            <span class="apidocSignatureSpan">(concurrency, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.processJob">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>processJob
            <span class="apidocSignatureSpan">(job)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.processJobs">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>processJobs
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.resume">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>resume
            <span class="apidocSignatureSpan">(isLocal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.retryJob">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>retryJob
            <span class="apidocSignatureSpan">(job)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.run">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>run
            <span class="apidocSignatureSpan">(concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.setHandler">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>setHandler
            <span class="apidocSignatureSpan">(handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.startMoveUnlockedJobsToWait">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>startMoveUnlockedJobsToWait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.toKey">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>toKey
            <span class="apidocSignatureSpan">(queueType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.updateDelayTimer">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>updateDelayTimer
            <span class="apidocSignatureSpan">(newDelayedTimestamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.whenCurrentJobsFinished">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>whenCurrentJobsFinished
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.queue.prototype.whenCurrentMoveFinished">
            function <span class="apidocSignatureSpan">bull.queue.prototype.</span>whenCurrentMoveFinished
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.scripts">module bull.scripts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts._isJobInList">
            function <span class="apidocSignatureSpan">bull.scripts.</span>_isJobInList
            <span class="apidocSignatureSpan">(keyVar, argVar, operator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.addJob">
            function <span class="apidocSignatureSpan">bull.scripts.</span>addJob
            <span class="apidocSignatureSpan">(client, toKey, job, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.cleanJobsInSet">
            function <span class="apidocSignatureSpan">bull.scripts.</span>cleanJobsInSet
            <span class="apidocSignatureSpan">(queue, set, ts, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.isJobInList">
            function <span class="apidocSignatureSpan">bull.scripts.</span>isJobInList
            <span class="apidocSignatureSpan">(client, listKey, jobId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.move">
            function <span class="apidocSignatureSpan">bull.scripts.</span>move
            <span class="apidocSignatureSpan">(job, src, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.moveToCompleted">
            function <span class="apidocSignatureSpan">bull.scripts.</span>moveToCompleted
            <span class="apidocSignatureSpan">(job, removeOnComplete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.moveToSet">
            function <span class="apidocSignatureSpan">bull.scripts.</span>moveToSet
            <span class="apidocSignatureSpan">(queue, set, jobId, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.moveUnlockedJobsToWait">
            function <span class="apidocSignatureSpan">bull.scripts.</span>moveUnlockedJobsToWait
            <span class="apidocSignatureSpan">(queue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.releaseLock">
            function <span class="apidocSignatureSpan">bull.scripts.</span>releaseLock
            <span class="apidocSignatureSpan">(job)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.remove">
            function <span class="apidocSignatureSpan">bull.scripts.</span>remove
            <span class="apidocSignatureSpan">(queue, jobId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.reprocessJob">
            function <span class="apidocSignatureSpan">bull.scripts.</span>reprocessJob
            <span class="apidocSignatureSpan">(job, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.takeLock">
            function <span class="apidocSignatureSpan">bull.scripts.</span>takeLock
            <span class="apidocSignatureSpan">(queue, job, renew, ensureActive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.scripts.updateDelaySet">
            function <span class="apidocSignatureSpan">bull.scripts.</span>updateDelaySet
            <span class="apidocSignatureSpan">(queue, delayedTimestamp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.super_">module bull.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.super_.super_">
            function <span class="apidocSignatureSpan">bull.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.super_.prototype">module bull.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.super_.prototype.distEmit">
            function <span class="apidocSignatureSpan">bull.super_.prototype.</span>distEmit
            <span class="apidocSignatureSpan">(evt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.super_.prototype.off">
            function <span class="apidocSignatureSpan">bull.super_.prototype.</span>off
            <span class="apidocSignatureSpan">(evt, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.super_.prototype.on">
            function <span class="apidocSignatureSpan">bull.super_.prototype.</span>on
            <span class="apidocSignatureSpan">(evt, listener, isGlobal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.super_.prototype.removeListener">
            function <span class="apidocSignatureSpan">bull.super_.prototype.</span>removeListener
            <span class="apidocSignatureSpan">(evt, listener)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.timer_manager">module bull.timer_manager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.timer_manager.timer_manager">
            function <span class="apidocSignatureSpan">bull.</span>timer_manager
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bull.timer_manager.prototype">module bull.timer_manager.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.timer_manager.prototype.clear">
            function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>clear
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.timer_manager.prototype.clearAll">
            function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>clearAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.timer_manager.prototype.set">
            function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>set
            <span class="apidocSignatureSpan">(name, delay, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bull.timer_manager.prototype.whenIdle">
            function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>whenIdle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull" id="apidoc.module.bull">module bull</a></h1>


    <h2>
        <a href="#apidoc.element.bull.bull" id="apidoc.element.bull.bull">
        function <span class="apidocSignatureSpan"></span>bull
        <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue(name, redisPort, redisHost, redisOptions){
  if(!(this instanceof Queue)){
    return new Queue(name, redisPort, redisHost, redisOptions);
  }

  if(_.isObject(redisPort)) {
    var opts = redisPort;
    var redisOpts = opts.redis || {};
    redisPort = redisOpts.port;
    redisHost = redisOpts.host;
    redisOptions = redisOpts.opts || {};
    redisOptions.db = redisOpts.DB || redisOpts.DB;
  } else if(parseInt(redisPort) == redisPort) {
    redisPort = parseInt(redisPort);
    redisOptions =  redisOptions || {};
  } else if(_.isString(redisPort)) {
    try {
      var redisUrl = url.parse(redisPort);
      assert(_.isObject(redisHost) || _.isUndefined(redisHost),
          &#x27;Expected an object as redis option&#x27;);
      redisOptions =  redisHost || {};
      redisPort = redisUrl.port;
      redisHost = redisUrl.hostname;
      if (redisUrl.auth) {
        redisOptions.password = redisUrl.auth.split(&#x27;:&#x27;)[1];
      }
    } catch (e) {
      throw new Error(e.message);
    }
  }

  redisOptions = redisOptions || {};

  function createClient(type) {
    var client;
    if(_.isFunction(redisOptions.createClient)){
      client = redisOptions.createClient(type);
    }else{
      client = new redis(redisPort, redisHost, redisOptions);
    }
    return client;
  }

  redisPort = redisPort || 6379;
  redisHost = redisHost || &#x27;127.0.0.1&#x27;;

  var _this = this;

  this.name = name;
  this.keyPrefix = redisOptions.keyPrefix || &#x27;bull&#x27;;

  //
  // We cannot use ioredis keyPrefix feature until we
  // stop creating keys dynamically in lua scripts.
  //
  delete redisOptions.keyPrefix;

  //
  // Create queue client (used to add jobs, pause queues, etc);
  //
  this.client = createClient(&#x27;client&#x27;);

  getRedisVersion(this.client).then(function(version){
    if(semver.lt(version, MINIMUM_REDIS_VERSION)){
      throw new Error(&#x27;Redis version needs to be greater than &#x27; + MINIMUM_REDIS_VERSION + &#x27;. Current: &#x27; + version);
    }
  }).catch(function(err){
    _this.emit(&#x27;error&#x27;, err);
  });

  //
  // Keep track of cluster clients for redlock
  //
  this.clients = [this.client];
  if (redisOptions.clients) {
    this.clients.push.apply(this.clients, redisOptions.clients);
  }
  this.redlock = {
    driftFactor: REDLOCK_DRIFT_FACTOR,
    retryCount: REDLOCK_RETRY_COUNT,
    retryDelay: REDLOCK_RETRY_DELAY
  };
  _.extend(this.redlock, redisOptions.redlock || {});

  //
  // Create blocking client (used to wait for jobs)
  //
  this.bclient = createClient(&#x27;block&#x27;);

  //
  // Create event subscriber client (receive messages from other instance of the queue)
  //
  this.eclient = createClient(&#x27;subscriber&#x27;);

  this.delayTimer = null;
  this.processing = 0;
  this.retrieving = 0;

  this.LOCK_RENEW_TIME = LOCK_RENEW_TIME;
  this.LOCK_DURATION = LOCK_DURATION;
  this.STALLED_JOB_CHECK_INTERVAL = STALLED_JOB_CHECK_INTERVAL;
  this.MAX_STALLED_JOB_COUNT = MAX_STALLED_JOB_COUNT;

  // bubble up Redis error events
  [this.client, this.bclient, this.eclient].forEach(function (client) {
    client.on(&#x27;error&#x27;, _this.emit.bind(_this, &#x27;error&#x27;));
  });

  // keeps track of active timers. used by close() to
  // ensure that disconnect() is deferred until all
  // scheduled redis commands have been executed
  this.timers = new TimerManager();

  // emit ready when redis connections ready
  var initializers = [this.client, this.bclient, this.eclient].map(function (client) {
    return new Promise(function(resolve, reject) {
      client.once(&#x27;ready&#x27;, resolve);
      client.once(&#x27;error&#x27;, reject);
    });
  });

  this._initializing = Promise.all(initializers).then(function(){
    return Promise.join(
      _this.eclient.subscribe(_this.toKey(&#x27;delayed&#x27;)),
      _this.eclient.subscribe(_this.toKey(&#x27;paused&#x27;))
    );
  }).then(function(){
    debuglog(name + &#x27; queue ready&#x27;);
    _this.emit(&#x27;ready&#x27;);
  }, function(err){
    console.error(&#x27;Error initializing queue:&#x27;, err);
  });

  Disturbed.call(this, _this.client, _this.eclient);

  //
  // Listen distributed queue events
  //
  listenDistEvent(&#x27;stalled&#x27;); //
  listenDistEvent(&#x27;active&#x27;); //
  listenDist ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job" id="apidoc.element.bull.job">
        function <span class="apidocSignatureSpan">bull.</span>job
        <span class="apidocSignatureSpan">(queue, data, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">job = function (queue, data, opts){
  opts = opts || {};
  this.queue = queue;
  this.data = data;
  this.opts = opts;
  this._progress = 0;
  this.delay = opts.delay || 0;
  this.timestamp = opts.timestamp || Date.now();
  this.stacktrace = [];
  if(this.opts.attempts &#x3e; 1){
    this.attempts = opts.attempts;
  }else{
    this.attempts = 1;
  }
  this.returnvalue = null;
  this.attemptsMade = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue" id="apidoc.element.bull.priority_queue">
        function <span class="apidocSignatureSpan">bull.</span>priority_queue
        <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priority_queue = function (name, redisPort, redisHost, redisOptions) {
  if (!(this instanceof PriorityQueue)) {
    return new PriorityQueue(name, redisPort, redisHost, redisOptions);
  }

  console.warn(&#x22;DEPRECATION NOTICE: PriorityQueue has been deprecated and will be removed in bull 3.0.0, please use the priority
 option instead.&#x22;);

  var _this = this;
  this.paused = false;
  this.queues = [];

  for (var key in PriorityQueue.priorities) {
    var queue = Queue(PriorityQueue.getQueueName(name, key), redisPort, redisHost, redisOptions);
    this.queues[PriorityQueue.priorities[key]] = queue;
  }

  var groupEvents = [&#x27;ready&#x27;, &#x27;paused&#x27;, &#x27;resumed&#x27;]
  groupEvents.forEach(function(event) {
    Promise.map(_this.queues, function(queue) {
      return new Promise(function(resolve, reject) {
        queue.once(event, resolve);
      });
    }).then(_this.emit.bind(_this, event))
  })

  var singleEvents = [&#x27;error&#x27;, &#x27;active&#x27;, &#x27;stalled&#x27;, &#x27;progress&#x27;, &#x27;completed&#x27;, &#x27;failed&#x27;, &#x27;cleaned&#x27;]
  singleEvents.forEach(function(event) {
    _this.queues.forEach(function(queue) {
      queue.on(event, _this.emit.bind(_this, event))
    })
  })

  this.strategy = Strategy.exponential;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue" id="apidoc.element.bull.queue">
        function <span class="apidocSignatureSpan">bull.</span>queue
        <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue(name, redisPort, redisHost, redisOptions){
  if(!(this instanceof Queue)){
    return new Queue(name, redisPort, redisHost, redisOptions);
  }

  if(_.isObject(redisPort)) {
    var opts = redisPort;
    var redisOpts = opts.redis || {};
    redisPort = redisOpts.port;
    redisHost = redisOpts.host;
    redisOptions = redisOpts.opts || {};
    redisOptions.db = redisOpts.DB || redisOpts.DB;
  } else if(parseInt(redisPort) == redisPort) {
    redisPort = parseInt(redisPort);
    redisOptions =  redisOptions || {};
  } else if(_.isString(redisPort)) {
    try {
      var redisUrl = url.parse(redisPort);
      assert(_.isObject(redisHost) || _.isUndefined(redisHost),
          &#x27;Expected an object as redis option&#x27;);
      redisOptions =  redisHost || {};
      redisPort = redisUrl.port;
      redisHost = redisUrl.hostname;
      if (redisUrl.auth) {
        redisOptions.password = redisUrl.auth.split(&#x27;:&#x27;)[1];
      }
    } catch (e) {
      throw new Error(e.message);
    }
  }

  redisOptions = redisOptions || {};

  function createClient(type) {
    var client;
    if(_.isFunction(redisOptions.createClient)){
      client = redisOptions.createClient(type);
    }else{
      client = new redis(redisPort, redisHost, redisOptions);
    }
    return client;
  }

  redisPort = redisPort || 6379;
  redisHost = redisHost || &#x27;127.0.0.1&#x27;;

  var _this = this;

  this.name = name;
  this.keyPrefix = redisOptions.keyPrefix || &#x27;bull&#x27;;

  //
  // We cannot use ioredis keyPrefix feature until we
  // stop creating keys dynamically in lua scripts.
  //
  delete redisOptions.keyPrefix;

  //
  // Create queue client (used to add jobs, pause queues, etc);
  //
  this.client = createClient(&#x27;client&#x27;);

  getRedisVersion(this.client).then(function(version){
    if(semver.lt(version, MINIMUM_REDIS_VERSION)){
      throw new Error(&#x27;Redis version needs to be greater than &#x27; + MINIMUM_REDIS_VERSION + &#x27;. Current: &#x27; + version);
    }
  }).catch(function(err){
    _this.emit(&#x27;error&#x27;, err);
  });

  //
  // Keep track of cluster clients for redlock
  //
  this.clients = [this.client];
  if (redisOptions.clients) {
    this.clients.push.apply(this.clients, redisOptions.clients);
  }
  this.redlock = {
    driftFactor: REDLOCK_DRIFT_FACTOR,
    retryCount: REDLOCK_RETRY_COUNT,
    retryDelay: REDLOCK_RETRY_DELAY
  };
  _.extend(this.redlock, redisOptions.redlock || {});

  //
  // Create blocking client (used to wait for jobs)
  //
  this.bclient = createClient(&#x27;block&#x27;);

  //
  // Create event subscriber client (receive messages from other instance of the queue)
  //
  this.eclient = createClient(&#x27;subscriber&#x27;);

  this.delayTimer = null;
  this.processing = 0;
  this.retrieving = 0;

  this.LOCK_RENEW_TIME = LOCK_RENEW_TIME;
  this.LOCK_DURATION = LOCK_DURATION;
  this.STALLED_JOB_CHECK_INTERVAL = STALLED_JOB_CHECK_INTERVAL;
  this.MAX_STALLED_JOB_COUNT = MAX_STALLED_JOB_COUNT;

  // bubble up Redis error events
  [this.client, this.bclient, this.eclient].forEach(function (client) {
    client.on(&#x27;error&#x27;, _this.emit.bind(_this, &#x27;error&#x27;));
  });

  // keeps track of active timers. used by close() to
  // ensure that disconnect() is deferred until all
  // scheduled redis commands have been executed
  this.timers = new TimerManager();

  // emit ready when redis connections ready
  var initializers = [this.client, this.bclient, this.eclient].map(function (client) {
    return new Promise(function(resolve, reject) {
      client.once(&#x27;ready&#x27;, resolve);
      client.once(&#x27;error&#x27;, reject);
    });
  });

  this._initializing = Promise.all(initializers).then(function(){
    return Promise.join(
      _this.eclient.subscribe(_this.toKey(&#x27;delayed&#x27;)),
      _this.eclient.subscribe(_this.toKey(&#x27;paused&#x27;))
    );
  }).then(function(){
    debuglog(name + &#x27; queue ready&#x27;);
    _this.emit(&#x27;ready&#x27;);
  }, function(err){
    console.error(&#x27;Error initializing queue:&#x27;, err);
  });

  Disturbed.call(this, _this.client, _this.eclient);

  //
  // Listen distributed queue events
  //
  listenDistEvent(&#x27;stalled&#x27;); //
  listenDistEvent(&#x27;active&#x27;); //
  listenDist ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.super_" id="apidoc.element.bull.super_">
        function <span class="apidocSignatureSpan">bull.</span>super_
        <span class="apidocSignatureSpan">(pubClient, subClient)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (pubClient, subClient) {
  var _this = this;
  EventEmitter.call(this);

  this.uuid = uuid();
  this.pubClient = pubClient;
  this.subClient = subClient;

  subClient.on(&#x27;message&#x27;, function (channel, msg) {

    var count = _this.listenerCount(channel);
    if (count) {
      var args;
      try {
        args = JSON.parse(msg);
      } catch (err) {
        console.error(&#x27;Parsing event message&#x27;, err);
      }

      if (args[0] !== _this.uuid) {
        args[0] = channel;
        _this.emit.apply(_this, args);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.timer_manager" id="apidoc.element.bull.timer_manager">
        function <span class="apidocSignatureSpan">bull.</span>timer_manager
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimerManager(){
  this.idle = true;
  this.listeners = [];
  this.timers = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.job" id="apidoc.module.bull.job">module bull.job</a></h1>


    <h2>
        <a href="#apidoc.element.bull.job.job" id="apidoc.element.bull.job.job">
        function <span class="apidocSignatureSpan">bull.</span>job
        <span class="apidocSignatureSpan">(queue, data, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">job = function (queue, data, opts){
  opts = opts || {};
  this.queue = queue;
  this.data = data;
  this.opts = opts;
  this._progress = 0;
  this.delay = opts.delay || 0;
  this.timestamp = opts.timestamp || Date.now();
  this.stacktrace = [];
  if(this.opts.attempts &#x3e; 1){
    this.attempts = opts.attempts;
  }else{
    this.attempts = 1;
  }
  this.returnvalue = null;
  this.attemptsMade = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.create" id="apidoc.element.bull.job.create">
        function <span class="apidocSignatureSpan">bull.job.</span>create
        <span class="apidocSignatureSpan">(queue, data, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (queue, data, opts){
  var job = new Job(queue, data, opts);

  return addJob(queue, job).then(function(jobId){
    job.jobId = jobId;
    queue.distEmit(&#x27;waiting&#x27;, job.toJSON());
    debuglog(&#x27;Job added&#x27;, jobId);
    return job;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.fromData" id="apidoc.element.bull.job.fromData">
        function <span class="apidocSignatureSpan">bull.job.</span>fromData
        <span class="apidocSignatureSpan">(queue, jobId, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromData = function (queue, jobId, data){
  var job = new Job(queue, JSON.parse(data.data), JSON.parse(data.opts));
  job.jobId = jobId;
  job._progress = parseInt(data.progress);
  job.delay = parseInt(data.delay);
  job.timestamp = parseInt(data.timestamp);

  job.failedReason = data.failedReason;
  job.attempts = parseInt(data.attempts);
  if(isNaN(job.attempts)) {
    job.attempts = 1; // Default to 1 try for legacy jobs
  }
  job.attemptsMade = parseInt(data.attemptsMade);
  var _traces;
  try{
    _traces = JSON.parse(data.stacktrace);
    if(!(_traces instanceof Array)){
      _traces = [];
    }
  }catch (err){
    _traces = [];
  }

  job.stacktrace = _traces;
  try{
    job.returnvalue = JSON.parse(data.returnvalue);
  }catch (e){
    //swallow exception because the returnvalue got corrupted somehow.
    debuglog(&#x27;corrupted returnvalue: &#x27; + data.returnvalue, e);
  }
  return job;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Job.fromId = function(queue, jobId){
  // jobId can be undefined if moveJob returns undefined
  if(!jobId) {
    return Promise.resolve();
  }
  return queue.client.hgetall(queue.toKey(jobId)).then(function(jobData){
    if(!_.isEmpty(jobData)){
      return Job.<span class="apidocCodeKeywordSpan">fromData</span>(queue, jobId, jobData);
    }else{
      return null;
    }
  });
};

Job.prototype.toData = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.fromId" id="apidoc.element.bull.job.fromId">
        function <span class="apidocSignatureSpan">bull.job.</span>fromId
        <span class="apidocSignatureSpan">(queue, jobId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromId = function (queue, jobId){
  // jobId can be undefined if moveJob returns undefined
  if(!jobId) {
    return Promise.resolve();
  }
  return queue.client.hgetall(queue.toKey(jobId)).then(function(jobData){
    if(!_.isEmpty(jobData)){
      return Job.fromData(queue, jobId, jobData);
    }else{
      return null;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var _this = this;

function status(resolve, reject){
  return _this.isCompleted().then(function(completed){
    if(!completed){
      return _this.isFailed().then(function(failed){
        if(failed){
          return Job.<span class="apidocCodeKeywordSpan">fromId</span>(_this.queue, _this.jobId, &#x27;failedReason&#x27;).then(
function(data){
            reject(Error(data.failedReason));
            return true;
          });
        }
      });
    }
    resolve();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.fromJSON" id="apidoc.element.bull.job.fromJSON">
        function <span class="apidocSignatureSpan">bull.job.</span>fromJSON
        <span class="apidocSignatureSpan">(queue, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (queue, json){
  var job = new Job(queue, json.data, json.opts);
  job.jobId = json.opts.jobId;
  job._progress = parseInt(json.progress);
  job.delay = parseInt(json.delay);
  job.timestamp = parseInt(json.timestamp);
  job.attempts = parseInt(json.attempts);
  if(isNaN(job.attempts)) {
    job.attempts = 1; // Default to 1 try for legacy jobs
  }
  job.attemptsMade = parseInt(json.attemptsMade);
  var _traces;
  try{
    _traces = JSON.parse(json.stacktrace);
    if(!(_traces instanceof Array)){
      _traces = [];
    }
  }catch (err){
    _traces = [];
  }

  job.stacktrace = _traces;
  try{
    job.returnvalue = JSON.parse(json.returnvalue);
  }catch (e){
    //swallow exception because the returnvalue got corrupted somehow.
    debuglog(&#x27;corrupted returnvalue: &#x27; + json.returnvalue, e);
  }
  return job;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.job.prototype" id="apidoc.module.bull.job.prototype">module bull.job.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bull.job.prototype._getBackOff" id="apidoc.element.bull.job.prototype._getBackOff">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>_getBackOff
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getBackOff = function () {
  var backoff = 0;
  var delay;
  if(this.opts.backoff){
    if(!isNaN(this.opts.backoff)){
      backoff = this.opts.backoff;
    }else if(this.opts.backoff.type === &#x27;fixed&#x27;){
      backoff = this.opts.backoff.delay;
    }else if(this.opts.backoff.type === &#x27;exponential&#x27;){
      delay = this.opts.backoff.delay;
      backoff = Math.round((Math.pow(2, this.attemptsMade) - 1) * delay);
    }
  }
  return backoff;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Job.prototype.moveToFailed = function(err){
var _this = this;
return this._saveAttempt(err).then(function() {
  // Check if an automatic retry should be performed
  if(_this.attemptsMade &#x3c; _this.attempts &#x26;&#x26; !_this._discarded){
    // Check if backoff is needed
    var backoff = _this.<span class="apidocCodeKeywordSpan">_getBackOff</span>();
    if(backoff){
      // If so, move to delayed
      return _this.moveToDelayed(Date.now() + backoff);
    }else{
      // If not, retry immediately
      return _this._retryAtOnce();
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype._isDone" id="apidoc.element.bull.job.prototype._isDone">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>_isDone
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isDone = function (list){
  return this.queue.client
    .sismember(this.queue.toKey(list), this.jobId).then(function(isMember){
      return isMember === 1;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (result === -2) {
      throw new Error(&#x27;Couldn\&#x27;t retry job: The job has been already retried or has not failed&#x27;);
    }
  });
};

Job.prototype.isCompleted = function(){
  return this.<span class="apidocCodeKeywordSpan">_isDone</span>(&#x27;completed&#x27;);
};

Job.prototype.isFailed = function(){
  return this._isDone(&#x27;failed&#x27;);
};

Job.prototype.isDelayed = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype._isInList" id="apidoc.element.bull.job.prototype._isInList">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>_isInList
        <span class="apidocSignatureSpan">(list)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isInList = function (list) {
  return scripts.isJobInList(this.queue.client, this.queue.toKey(list), this.jobId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.queue.client
    .zrank(this.queue.toKey(&#x27;delayed&#x27;), this.jobId).then(function(rank) {
      return rank !== null;
    });
};

Job.prototype.isActive = function() {
  return this.<span class="apidocCodeKeywordSpan">_isInList</span>(&#x27;active&#x27;);
};

Job.prototype.isWaiting = function() {
  return this._isInList(&#x27;wait&#x27;);
};

Job.prototype.isPaused = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype._moveToSet" id="apidoc.element.bull.job.prototype._moveToSet">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>_moveToSet
        <span class="apidocSignatureSpan">(set, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_moveToSet = function (set, context){
  var queue = this.queue;
  var jobId = this.jobId;

  return scripts.moveToSet(queue, set, jobId, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    } else if(_this.opts.removeOnFail){
      return _this.releaseLock().then(function(){
        return _this.remove();
      });
    }
    // If not, move to failed
    return _this.<span class="apidocCodeKeywordSpan">_moveToSet</span>(&#x27;failed&#x27;);
  });
};

Job.prototype.moveToDelayed = function(timestamp){
  return this._moveToSet(&#x27;delayed&#x27;, timestamp);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype._retryAtOnce" id="apidoc.element.bull.job.prototype._retryAtOnce">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>_retryAtOnce
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_retryAtOnce = function (){
  var queue = this.queue;
  var jobId = this.jobId;

  var script = [
    &#x27;if redis.call(&#x22;EXISTS&#x22;, KEYS[3]) == 1 then&#x27;,
    &#x27; redis.call(&#x22;LREM&#x22;, KEYS[1], 0, ARGV[2])&#x27;,
    &#x27; redis.call(ARGV[1], KEYS[2], ARGV[2])&#x27;,
    &#x27; return 0&#x27;,
    &#x27;else&#x27;,
    &#x27; return -1&#x27;,
    &#x27;end&#x27;
  ].join(&#x27;\n&#x27;);

  var keys = _.map([&#x27;active&#x27;, &#x27;wait&#x27;, jobId], function(name){
    return queue.toKey(name);
  });

  var pushCmd = (this.opts.lifo ? &#x27;R&#x27; : &#x27;L&#x27;) + &#x27;PUSH&#x27;;

  return queue.client.eval(
    script,
    keys.length,
    keys[0],
    keys[1],
    keys[2],
    pushCmd,
    jobId).then(function(result){
      if(result === -1){
        throw new Error(&#x27;Missing Job &#x27; + jobId + &#x27; during retry&#x27;);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Check if backoff is needed
  var backoff = _this._getBackOff();
  if(backoff){
    // If so, move to delayed
    return _this.moveToDelayed(Date.now() + backoff);
  }else{
    // If not, retry immediately
    return _this.<span class="apidocCodeKeywordSpan">_retryAtOnce</span>();
  }
} else if(_this.opts.removeOnFail){
  return _this.releaseLock().then(function(){
    return _this.remove();
  });
}
// If not, move to failed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype._saveAttempt" id="apidoc.element.bull.job.prototype._saveAttempt">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>_saveAttempt
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_saveAttempt = function (err){
  if(isNaN(this.attemptsMade)){
    this.attemptsMade = 1;
  }else{
    this.attemptsMade++;
  }
  var params = {
    attemptsMade: this.attemptsMade
  };

  this.stacktrace.push(err.stack);
  params.stacktrace = JSON.stringify(this.stacktrace);

  params.failedReason = err.message;

  return this.queue.client.hmset(this.queue.toKey(this.jobId), params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Job.prototype.discard = function(){
this._discarded = true;
}

Job.prototype.moveToFailed = function(err){
var _this = this;
return this.<span class="apidocCodeKeywordSpan">_saveAttempt</span>(err).then(function() {
  // Check if an automatic retry should be performed
  if(_this.attemptsMade &#x3c; _this.attempts &#x26;&#x26; !_this._discarded){
    // Check if backoff is needed
    var backoff = _this._getBackOff();
    if(backoff){
      // If so, move to delayed
      return _this.moveToDelayed(Date.now() + backoff);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.delayIfNeeded" id="apidoc.element.bull.job.prototype.delayIfNeeded">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>delayIfNeeded
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delayIfNeeded = function (){
  if(this.delay){
    var jobDelayedTimestamp = this.timestamp + this.delay;
    if(jobDelayedTimestamp &#x3e; Date.now()){
      return this.moveToDelayed(jobDelayedTimestamp).then(function(){
        return true;
      });
    }
  }
  return Promise.resolve(false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.discard" id="apidoc.element.bull.job.prototype.discard">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>discard
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discard = function (){
  this._discarded = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.finished" id="apidoc.element.bull.job.prototype.finished">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>finished
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finished = function (){
  var _this = this;

  function status(resolve, reject){
    return _this.isCompleted().then(function(completed){
      if(!completed){
        return _this.isFailed().then(function(failed){
          if(failed){
            return Job.fromId(_this.queue, _this.jobId, &#x27;failedReason&#x27;).then(function(data){
              reject(Error(data.failedReason));
              return true;
            });
          }
        });
      }
      resolve();
      return true;
    });
  }

  return new Promise(function(resolve, reject){
    status(resolve, reject).then(function(finished){
      if(!finished){
        var interval;
        function onCompleted(job){
          if(String(job.jobId) === String(_this.jobId)){
            resolve();
            removeListeners();
            clearInterval(interval);
          }
        }

        function onFailed(job, err){
          if(String(job.jobId) === String(_this.jobId)){
            reject(err);
            removeListeners();
            clearInterval(interval);
          }
        }

        function removeListeners(){
          _this.queue.removeListener(&#x27;completed&#x27;, onCompleted);
          _this.queue.removeListener(&#x27;failed&#x27;, onFailed);
        }

        _this.queue.on(&#x27;completed&#x27;, onCompleted);
        _this.queue.on(&#x27;failed&#x27;, onFailed);

        //
        // Watchdog
        //
        interval = setInterval(function(){
          status(resolve, reject).then(function(finished){
            if(finished){
              removeListeners();
              clearInterval(interval );
            }
          })
        }, 5000);
      };
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.getState" id="apidoc.element.bull.job.prototype.getState">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>getState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getState = function () {
  var _this = this;
  var fns = [
    { fn: &#x27;isCompleted&#x27;, state: &#x27;completed&#x27; },
    { fn: &#x27;isFailed&#x27;, state: &#x27;failed&#x27; },
    { fn: &#x27;isDelayed&#x27;, state: &#x27;delayed&#x27; },
    { fn: &#x27;isActive&#x27;, state: &#x27;active&#x27; },
    { fn: &#x27;isWaiting&#x27;, state: &#x27;waiting&#x27; },
    { fn: &#x27;isPaused&#x27;, state: &#x27;paused&#x27; }
  ];

  return Promise.reduce(fns, function(state, fn) {
    if(state){
      return state;
    }
    return _this[fn.fn]().then(function(result) {
      return result ? fn.state : null;
    });
  }, null).then(function(result) {
    return result ? result : &#x27;stuck&#x27;;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Job.prototype.isPaused = function() {
return this._isInList(&#x27;paused&#x27;);
};

Job.prototype.isStuck = function() {
return this.<span class="apidocCodeKeywordSpan">getState</span>().then(function(state) {
  return state === &#x27;stuck&#x27;;
});
};

Job.prototype.getState = function() {
var _this = this;
var fns = [
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.isActive" id="apidoc.element.bull.job.prototype.isActive">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>isActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isActive = function () {
  return this._isInList(&#x27;active&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.isCompleted" id="apidoc.element.bull.job.prototype.isCompleted">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>isCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCompleted = function (){
  return this._isDone(&#x27;completed&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * TODO: Add a watchdog to check if the job has finished periodically.
 * since pubsub does not give any guarantees.
 */
Job.prototype.finished = function(){
var _this = this;

function status(resolve, reject){
  return _this.<span class="apidocCodeKeywordSpan">isCompleted</span>().then(function(completed){
    if(!completed){
      return _this.isFailed().then(function(failed){
        if(failed){
          return Job.fromId(_this.queue, _this.jobId, &#x27;failedReason&#x27;).then(function(data){
            reject(Error(data.failedReason));
            return true;
          });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.isDelayed" id="apidoc.element.bull.job.prototype.isDelayed">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>isDelayed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDelayed = function () {
  return this.queue.client
    .zrank(this.queue.toKey(&#x27;delayed&#x27;), this.jobId).then(function(rank) {
      return rank !== null;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.isFailed" id="apidoc.element.bull.job.prototype.isFailed">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>isFailed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFailed = function (){
  return this._isDone(&#x27;failed&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Job.prototype.finished = function(){
var _this = this;

function status(resolve, reject){
  return _this.isCompleted().then(function(completed){
    if(!completed){
      return _this.<span class="apidocCodeKeywordSpan">isFailed</span>().then(function(failed){
        if(failed){
          return Job.fromId(_this.queue, _this.jobId, &#x27;failedReason&#x27;).then(function(data){
            reject(Error(data.failedReason));
            return true;
          });
        }
      });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.isPaused" id="apidoc.element.bull.job.prototype.isPaused">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>isPaused
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPaused = function () {
  return this._isInList(&#x27;paused&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.isStuck" id="apidoc.element.bull.job.prototype.isStuck">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>isStuck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isStuck = function () {
  return this.getState().then(function(state) {
    return state === &#x27;stuck&#x27;;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.isWaiting" id="apidoc.element.bull.job.prototype.isWaiting">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>isWaiting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWaiting = function () {
  return this._isInList(&#x27;wait&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.lockKey" id="apidoc.element.bull.job.prototype.lockKey">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>lockKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lockKey = function (){
  return this.queue.toKey(this.jobId) + &#x27;:lock&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    extraLockArgs: [job.jobId]
  };
  redlock = new Redlock(queue.clients, _.extend(opts, queue.redlock));
} else {
  redlock = new Redlock(queue.clients, queue.redlock);
}

return redlock.lock(job.<span class="apidocCodeKeywordSpan">lockKey</span>(), queue.LOCK_DURATION).catch(function(err){
  //
  // Failing to lock due to already locked is not an error.
  //
  if(err.name != &#x27;LockError&#x27;){
    throw err;
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.move" id="apidoc.element.bull.job.prototype.move">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>move
        <span class="apidocSignatureSpan">(src, target, returnValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">move = function (src, target, returnValue){
  if(target === &#x27;completed&#x27;){
    this.returnvalue = returnValue || 0;
    if(this.opts.removeOnComplete){
      target = void 0;
    }
  }
  return scripts.move(this, src, target);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Job.prototype.move = function(src, target, returnValue){
  if(target === &#x27;completed&#x27;){
    this.returnvalue = returnValue || 0;
    if(this.opts.removeOnComplete){
      target = void 0;
    }
  }
  return scripts.<span class="apidocCodeKeywordSpan">move</span>(this, src, target);
}

Job.prototype.discard = function(){
  this._discarded = true;
}

Job.prototype.moveToFailed = function(err){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.moveToCompleted" id="apidoc.element.bull.job.prototype.moveToCompleted">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>moveToCompleted
        <span class="apidocSignatureSpan">(returnValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToCompleted = function (returnValue){
  this.returnvalue = returnValue || 0;
  return scripts.moveToCompleted(this, this.opts.removeOnComplete);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
return Promise.resolve(false);
};

Job.prototype.moveToCompleted = function(returnValue){
this.returnvalue = returnValue || 0;
return scripts.<span class="apidocCodeKeywordSpan">moveToCompleted</span>(this, this.opts.removeOnComplete);
};

Job.prototype.move = function(src, target, returnValue){
if(target === &#x27;completed&#x27;){
  this.returnvalue = returnValue || 0;
  if(this.opts.removeOnComplete){
    target = void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.moveToDelayed" id="apidoc.element.bull.job.prototype.moveToDelayed">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>moveToDelayed
        <span class="apidocSignatureSpan">(timestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToDelayed = function (timestamp){
  return this._moveToSet(&#x27;delayed&#x27;, timestamp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  .then(function() { _this.lock = null; });
};

Job.prototype.delayIfNeeded = function(){
  if(this.delay){
    var jobDelayedTimestamp = this.timestamp + this.delay;
    if(jobDelayedTimestamp &#x3e; Date.now()){
      return this.<span class="apidocCodeKeywordSpan">moveToDelayed</span>(jobDelayedTimestamp).then(function(){
        return true;
      });
    }
  }
  return Promise.resolve(false);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.moveToFailed" id="apidoc.element.bull.job.prototype.moveToFailed">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>moveToFailed
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToFailed = function (err){
  var _this = this;
  return this._saveAttempt(err).then(function() {
    // Check if an automatic retry should be performed
    if(_this.attemptsMade &#x3c; _this.attempts &#x26;&#x26; !_this._discarded){
      // Check if backoff is needed
      var backoff = _this._getBackOff();
      if(backoff){
        // If so, move to delayed
        return _this.moveToDelayed(Date.now() + backoff);
      }else{
        // If not, retry immediately
        return _this._retryAtOnce();
      }
    } else if(_this.opts.removeOnFail){
      return _this.releaseLock().then(function(){
        return _this.remove();
      });
    }
    // If not, move to failed
    return _this._moveToSet(&#x27;failed&#x27;);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.progress" id="apidoc.element.bull.job.prototype.progress">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>progress
        <span class="apidocSignatureSpan">(progress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">progress = function (progress){
  if(progress){
    var _this = this;
    this._progress = progress;
    return this.queue.client.hset(this.queue.toKey(this.jobId), &#x27;progress&#x27;, progress).then(function(){
      _this.queue.distEmit(&#x27;progress&#x27;, _this.toJSON(), progress);
    });
  }else{
    return this._progress;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

videoQueue.process(function(job, done){

// job.data contains the custom data passed when the job was created
// job.jobId contains id of this job.

// transcode video asynchronously and report progress
job.<span class="apidocCodeKeywordSpan">progress</span>(42);

// call done when finished
done();

// or give a error if error
done(Error(&#x27;error transcoding&#x27;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.promote" id="apidoc.element.bull.job.prototype.promote">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>promote
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promote = function (){
  var queue = this.queue;
  var jobId = this.jobId;

  var script = [
    &#x27;if redis.call(&#x22;ZREM&#x22;, KEYS[1], ARGV[1]) == 1 then&#x27;,
    &#x27; redis.call(&#x22;LPUSH&#x22;, KEYS[2], ARGV[1])&#x27;,
    &#x27; return 0&#x27;,
    &#x27;else&#x27;,
    &#x27; return -1&#x27;,
    &#x27;end&#x27;
  ].join(&#x27;\n&#x27;);

  var keys = _.map([&#x27;delayed&#x27;, &#x27;wait&#x27;], function(name){
    return queue.toKey(name);
  });

  return queue.client.eval(
    script,
    keys.length,
    keys[0],
    keys[1],
    jobId).then(function(result){
      if(result === -1){
        throw new Error(&#x27;Job &#x27; + jobId + &#x27; is not in a delayed state&#x27;);
      }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.releaseLock" id="apidoc.element.bull.job.prototype.releaseLock">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>releaseLock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">releaseLock = function (){
  var _this = this;
  return scripts.releaseLock(this)
  .then(function() { _this.lock = null; });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
Releases the lock. Only locks owned by the queue instance can be released.
*/
Job.prototype.releaseLock = function(){
var _this = this;
return scripts.<span class="apidocCodeKeywordSpan">releaseLock</span>(this)
.then(function() { _this.lock = null; });
};

Job.prototype.delayIfNeeded = function(){
if(this.delay){
  var jobDelayedTimestamp = this.timestamp + this.delay;
  if(jobDelayedTimestamp &#x3e; Date.now()){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.remove" id="apidoc.element.bull.job.prototype.remove">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>remove
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (){
  var queue = this.queue;
  var job = this;

  return job.takeLock().then(function(lock) {
    if (!lock) {
      throw new Error(&#x27;Could not get lock for job: &#x27; + job.jobId + &#x27;. Cannot remove job.&#x27;);
    }
    return scripts.remove(queue, job.jobId)
      .then(function() {
        queue.emit(&#x27;removed&#x27;, job.toJSON());
      })
      .finally(function () {
        return job.releaseLock();
      });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return _this.moveToDelayed(Date.now() + backoff);
      }else{
        // If not, retry immediately
        return _this._retryAtOnce();
      }
    } else if(_this.opts.removeOnFail){
      return _this.releaseLock().then(function(){
        return _this.<span class="apidocCodeKeywordSpan">remove</span>();
      });
    }
    // If not, move to failed
    return _this._moveToSet(&#x27;failed&#x27;);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.renewLock" id="apidoc.element.bull.job.prototype.renewLock">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>renewLock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renewLock = function (){
  return this.takeLock(true /* Renew */);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.retry" id="apidoc.element.bull.job.prototype.retry">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>retry
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retry = function (){
  var queue = this.queue;
  var _this = this;
  return scripts.reprocessJob(this, { state: &#x27;failed&#x27; }).then(function(result) {
    if (result === 1) {
      queue.emit(&#x27;waiting&#x27;, _this);
    } else if (result === 0) {
      throw new Error(&#x27;Couldn\&#x27;t retry job: The job doesn\&#x27;t exist&#x27;);
    } else if (result === -1) {
      throw new Error(&#x27;Couldn\&#x27;t retry job: The job is locked&#x27;);
    } else if (result === -2) {
      throw new Error(&#x27;Couldn\&#x27;t retry job: The job has been already retried or has not failed&#x27;);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.takeLock" id="apidoc.element.bull.job.prototype.takeLock">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>takeLock
        <span class="apidocSignatureSpan">(renew, ensureActive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeLock = function (renew, ensureActive){
  var _this = this;
  return scripts.takeLock(this.queue, this, renew, ensureActive).then(function(lock) {
    if (lock){
      _this.lock = lock;
    }
    return lock || false;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
  Takes a lock for this job so that no other queue worker can process it at the
  same time.
*/
Job.prototype.takeLock = function(renew, ensureActive){
  var _this = this;
  return scripts.<span class="apidocCodeKeywordSpan">takeLock</span>(this.queue, this, renew, ensureActive).then(function(lock) {
    if (lock){
      _this.lock = lock;
    }
    return lock || false;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.toData" id="apidoc.element.bull.job.prototype.toData">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>toData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toData = function (){
  return {
    data: JSON.stringify(this.data || {}),
    opts: JSON.stringify(this.opts || {}),
    progress: this._progress,
    delay: this.delay,
    timestamp: this.timestamp,
    attempts: this.attempts,
    attemptsMade: this.attemptsMade,
    failedReason: this.failedReason,
    stacktrace: JSON.stringify(this.stacktrace || null),
    returnvalue: JSON.stringify(this.returnvalue || null)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  this.returnvalue = null;
  this.attemptsMade = 0;
};

function addJob(queue, job){
  var opts = job.opts;
  var jobData = job.<span class="apidocCodeKeywordSpan">toData</span>();
  var toKey = _.bind(queue.toKey, queue);
  return scripts.addJob(queue.client, toKey, jobData, {
    lifo: opts.lifo,
    customJobId: opts.jobId,
    priority: opts.priority
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.job.prototype.toJSON" id="apidoc.element.bull.job.prototype.toJSON">
        function <span class="apidocSignatureSpan">bull.job.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (){
  var opts = _.extend({}, this.opts || {});
  opts.jobId = this.jobId;
  return {
    id: this.jobId,
    data: this.data || {},
    opts: opts,
    progress: this._progress,
    delay: this.delay,
    timestamp: this.timestamp,
    attempts: this.attempts,
    attemptsMade: this.attemptsMade,
    failedReason: this.failedReason,
    stacktrace: this.stacktrace || null,
    returnvalue: this.returnvalue || null
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Job.create = function(queue, data, opts){
var job = new Job(queue, data, opts);

return addJob(queue, job).then(function(jobId){
  job.jobId = jobId;
  queue.distEmit(&#x27;waiting&#x27;, job.<span class="apidocCodeKeywordSpan">toJSON</span>());
  debuglog(&#x27;Job added&#x27;, jobId);
  return job;
});
};

Job.fromId = function(queue, jobId){
// jobId can be undefined if moveJob returns undefined
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.priority_queue" id="apidoc.module.bull.priority_queue">module bull.priority_queue</a></h1>


    <h2>
        <a href="#apidoc.element.bull.priority_queue.priority_queue" id="apidoc.element.bull.priority_queue.priority_queue">
        function <span class="apidocSignatureSpan">bull.</span>priority_queue
        <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priority_queue = function (name, redisPort, redisHost, redisOptions) {
  if (!(this instanceof PriorityQueue)) {
    return new PriorityQueue(name, redisPort, redisHost, redisOptions);
  }

  console.warn(&#x22;DEPRECATION NOTICE: PriorityQueue has been deprecated and will be removed in bull 3.0.0, please use the priority
 option instead.&#x22;);

  var _this = this;
  this.paused = false;
  this.queues = [];

  for (var key in PriorityQueue.priorities) {
    var queue = Queue(PriorityQueue.getQueueName(name, key), redisPort, redisHost, redisOptions);
    this.queues[PriorityQueue.priorities[key]] = queue;
  }

  var groupEvents = [&#x27;ready&#x27;, &#x27;paused&#x27;, &#x27;resumed&#x27;]
  groupEvents.forEach(function(event) {
    Promise.map(_this.queues, function(queue) {
      return new Promise(function(resolve, reject) {
        queue.once(event, resolve);
      });
    }).then(_this.emit.bind(_this, event))
  })

  var singleEvents = [&#x27;error&#x27;, &#x27;active&#x27;, &#x27;stalled&#x27;, &#x27;progress&#x27;, &#x27;completed&#x27;, &#x27;failed&#x27;, &#x27;cleaned&#x27;]
  singleEvents.forEach(function(event) {
    _this.queues.forEach(function(queue) {
      queue.on(event, _this.emit.bind(_this, event))
    })
  })

  this.strategy = Strategy.exponential;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.genericGetter" id="apidoc.element.bull.priority_queue.genericGetter">
        function <span class="apidocSignatureSpan">bull.priority_queue.</span>genericGetter
        <span class="apidocSignatureSpan">(fnName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genericGetter = function (fnName) {
  return function() {
    var args = arguments;
    return Promise.map(this.queues, function(queue) {
      return queue[fnName].apply(queue, args);
    }).then(function(results) {
      var jobs = [];
      results.forEach(function(val) {
        jobs = jobs.concat(val);
      });
      return jobs;
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        jobs = jobs.concat(val);
      });
      return jobs;
    })
  }
}

PriorityQueue.prototype.getWaiting = PriorityQueue.<span class="apidocCodeKeywordSpan">genericGetter</span>(&#x22;getWaiting&#x22
;);
PriorityQueue.prototype.getActive = PriorityQueue.genericGetter(&#x22;getActive&#x22;);
PriorityQueue.prototype.getDelayed = PriorityQueue.genericGetter(&#x22;getDelayed&#x22;);
PriorityQueue.prototype.getCompleted = PriorityQueue.genericGetter(&#x22;getCompleted&#x22;);
PriorityQueue.prototype.getFailed = PriorityQueue.genericGetter(&#x22;getFailed&#x22;);


// ---------------------------------------------------------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.getQueueName" id="apidoc.element.bull.priority_queue.getQueueName">
        function <span class="apidocSignatureSpan">bull.priority_queue.</span>getQueueName
        <span class="apidocSignatureSpan">(name, priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getQueueName = function (name, priority) {
  return name + &#x27;:prio:&#x27; + priority;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
console.warn(&#x22;DEPRECATION NOTICE: PriorityQueue has been deprecated and will be removed in bull 3.0.0, please use the priority
 option instead.&#x22;);

var _this = this;
this.paused = false;
this.queues = [];

for (var key in PriorityQueue.priorities) {
  var queue = Queue(PriorityQueue.<span class="apidocCodeKeywordSpan">getQueueName</span>(name, key), redisPort, redisHost, redisOptions
);
  this.queues[PriorityQueue.priorities[key]] = queue;
}

var groupEvents = [&#x27;ready&#x27;, &#x27;paused&#x27;, &#x27;resumed&#x27;]
groupEvents.forEach(function(event) {
  Promise.map(_this.queues, function(queue) {
    return new Promise(function(resolve, reject) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.super_" id="apidoc.element.bull.priority_queue.super_">
        function <span class="apidocSignatureSpan">bull.priority_queue.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.priority_queue.prototype" id="apidoc.module.bull.priority_queue.prototype">module bull.priority_queue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.add" id="apidoc.element.bull.priority_queue.prototype.add">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>add
        <span class="apidocSignatureSpan">(data, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (data, opts) {
  return this.getQueue(opts &#x26;&#x26; opts.priority).add(data, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

pdfQueue.process(function(job){
  // Processors can also return promises instead of using the done callback
  return pdfAsyncProcessor();
});

videoQueue.<span class="apidocCodeKeywordSpan">add</span>({video: &#x27;http://example.com/video1.mov&#x27;});
audioQueue.add({audio: &#x27;http://example.com/audio1.mp3&#x27;});
imageQueue.add({image: &#x27;http://example.com/image1.tiff&#x27;});
```

Alternatively, you can use return promises instead of using the `done` callback:

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.clean" id="apidoc.element.bull.priority_queue.prototype.clean">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>clean
        <span class="apidocSignatureSpan">(grace, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clean = function (grace, type) {
  var _this = this;
  return Promise.map(this.queues, function(queue) {
    return queue.clean(grace, type);
  }).then(function (results) {
    var jobs = [].concat.apply([], results);
    var tp = type || &#x27;completed&#x27;;
    _this.emit(&#x27;cleaned&#x27;, jobs, tp);
    return Promise.resolve(jobs);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Tells the queue remove jobs of a specific type created outside of a grace period.

__Example__

```javascript
//cleans all jobs that completed over 5 seconds ago.
queue.<span class="apidocCodeKeywordSpan">clean</span>(5000);
//clean all jobs that failed over 10 seconds ago.
queue.clean(10000, &#x27;failed&#x27;);
queue.on(&#x27;cleaned&#x27;, function (job, type) {
  console.log(&#x27;Cleaned %s %s jobs&#x27;, job.length, type);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.close" id="apidoc.element.bull.priority_queue.prototype.close">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>close
        <span class="apidocSignatureSpan">( doNotWaitJobs )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function ( doNotWaitJobs ) {
  return this.closing = Promise.map(this.queues, function(queue) {
    return queue.close( doNotWaitJobs );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
shutdown.

```javascript
var Queue = require(&#x27;bull&#x27;);
var queue = Queue(&#x27;example&#x27;);

var after100 = _.after(100, function () {
  queue.<span class="apidocCodeKeywordSpan">close</span>().then(function () { console.log(&#x27;done&#x27;) })
});

queue.on(&#x27;completed&#x27;, after100);
```

`close` can be called from anywhere, with one caveat: if called
from within a job handler the queue won&#x27;t close until *after*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.count" id="apidoc.element.bull.priority_queue.prototype.count">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>count
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function () {
  return Promise.map(this.queues, function(queue) {
    return queue.count();
  }).then(function(results) {
    var sum = 0;
    results.forEach(function(val) {
      sum += val;
    });
    return sum;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Promise.resolve(jobs);
});
}


PriorityQueue.prototype.count = function() {
return Promise.map(this.queues, function(queue) {
  return queue.<span class="apidocCodeKeywordSpan">count</span>();
}).then(function(results) {
  var sum = 0;
  results.forEach(function(val) {
    sum += val;
  });
  return sum;
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.disconnect" id="apidoc.element.bull.priority_queue.prototype.disconnect">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function () {
  return Promise.map(this.queues, function(queue) {
    return queue.disconnect();
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @type {number}
 */
PriorityQueue.prototype.waitAfterEmptyLoop = 200;

PriorityQueue.prototype.disconnect = function() {
return Promise.map(this.queues, function(queue) {
  return queue.<span class="apidocCodeKeywordSpan">disconnect</span>();
})
}

PriorityQueue.prototype.close = function( doNotWaitJobs ) {
return this.closing = Promise.map(this.queues, function(queue) {
  return queue.close( doNotWaitJobs );
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.empty" id="apidoc.element.bull.priority_queue.prototype.empty">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function () {
  return Promise.map(this.queues, function(queue) {
    return queue.empty();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

PriorityQueue.prototype.add = function(data, opts) {
return this.getQueue(opts &#x26;&#x26; opts.priority).add(data, opts);
}

PriorityQueue.prototype.empty = function() {
return Promise.map(this.queues, function(queue) {
  return queue.<span class="apidocCodeKeywordSpan">empty</span>();
});
}

PriorityQueue.prototype.pause = function(localOnly) {
var _this = this;

_this.paused = Promise.map(this.queues, function(queue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.getActive" id="apidoc.element.bull.priority_queue.prototype.getActive">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getActive = function () {
  var args = arguments;
  return Promise.map(this.queues, function(queue) {
    return queue[fnName].apply(queue, args);
  }).then(function(results) {
    var jobs = [];
    results.forEach(function(val) {
      jobs = jobs.concat(val);
    });
    return jobs;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.getCompleted" id="apidoc.element.bull.priority_queue.prototype.getCompleted">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCompleted = function () {
  var args = arguments;
  return Promise.map(this.queues, function(queue) {
    return queue[fnName].apply(queue, args);
  }).then(function(results) {
    var jobs = [];
    results.forEach(function(val) {
      jobs = jobs.concat(val);
    });
    return jobs;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.getDelayed" id="apidoc.element.bull.priority_queue.prototype.getDelayed">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getDelayed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDelayed = function () {
  var args = arguments;
  return Promise.map(this.queues, function(queue) {
    return queue[fnName].apply(queue, args);
  }).then(function(results) {
    var jobs = [];
    results.forEach(function(val) {
      jobs = jobs.concat(val);
    });
    return jobs;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.getFailed" id="apidoc.element.bull.priority_queue.prototype.getFailed">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getFailed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFailed = function () {
  var args = arguments;
  return Promise.map(this.queues, function(queue) {
    return queue[fnName].apply(queue, args);
  }).then(function(results) {
    var jobs = [];
    results.forEach(function(val) {
      jobs = jobs.concat(val);
    });
    return jobs;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.getQueue" id="apidoc.element.bull.priority_queue.prototype.getQueue">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getQueue
        <span class="apidocSignatureSpan">(priority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getQueue = function (priority) {
  if (!(priority in PriorityQueue.priorities)) {
    //in case of unknown priority, we use normal
    priority = &#x22;normal&#x22;;
  }

  var queue = this.queues[PriorityQueue.priorities[priority]];
  return queue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PriorityQueue.prototype.setLockRenewTime = function(lockRenewTime) {
  this.queues.forEach(function(queue) {
    queue.LOCK_RENEW_TIME = lockRenewTime;
  })
}

PriorityQueue.prototype.add = function(data, opts) {
  return this.<span class="apidocCodeKeywordSpan">getQueue</span>(opts &#x26;&#x26; opts.priority).add(data, opts);
}

PriorityQueue.prototype.empty = function() {
  return Promise.map(this.queues, function(queue) {
    return queue.empty();
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.getWaiting" id="apidoc.element.bull.priority_queue.prototype.getWaiting">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>getWaiting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWaiting = function () {
  var args = arguments;
  return Promise.map(this.queues, function(queue) {
    return queue[fnName].apply(queue, args);
  }).then(function(results) {
    var jobs = [];
    results.forEach(function(val) {
      jobs = jobs.concat(val);
    });
    return jobs;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.pause" id="apidoc.element.bull.priority_queue.prototype.pause">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>pause
        <span class="apidocSignatureSpan">(localOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function (localOnly) {
  var _this = this;

  _this.paused = Promise.map(this.queues, function(queue) {
    return queue.pause(localOnly || false);
  }).then(_this.emit.bind(_this, &#x27;paused&#x27;));

  return _this.paused;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Promise.reject(new Error(&#x27;some unexpected error&#x27;));
});
```

A queue can be paused and resumed globally (pass `true` to pause processing for
just this worker):
```javascript
queue.<span class="apidocCodeKeywordSpan">pause</span>().then(function(){
  // queue is paused now
});

queue.resume().then(function(){
  // queue is resumed now
})
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.process" id="apidoc.element.bull.priority_queue.prototype.process">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>process
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (handler) {
  this.handler = handler;
  this.queues.forEach(function(queue, key) {
    queue.setHandler(handler);
  });
  return this.run();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Queue = require(&#x27;bull&#x27;);

var videoQueue = Queue(&#x27;video transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);
var audioQueue = Queue(&#x27;audio transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);
var imageQueue = Queue(&#x27;image transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);
var pdfQueue = Queue(&#x27;pdf transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);

videoQueue.<span class="apidocCodeKeywordSpan">process</span>(function(job, done){

// job.data contains the custom data passed when the job was created
// job.jobId contains id of this job.

// transcode video asynchronously and report progress
job.progress(42);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.resume" id="apidoc.element.bull.priority_queue.prototype.resume">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>resume
        <span class="apidocSignatureSpan">(localOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function (localOnly) {
  var _this = this;
  _this.paused = false;
  return Promise.map(this.queues, function(queue) {
    return queue.resume(localOnly || false);
  }).then(_this.emit.bind(_this, &#x27;resumed&#x27;)).then(function() {
    if (_this.handler) {
      _this.run();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A queue can be paused and resumed globally (pass `true` to pause processing for
just this worker):
```javascript
queue.pause().then(function(){
  // queue is paused now
});

queue.<span class="apidocCodeKeywordSpan">resume</span>().then(function(){
  // queue is resumed now
})
```

A queue emits also some useful events:
```javascript
.on(&#x27;ready&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.run" id="apidoc.element.bull.priority_queue.prototype.run">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>run
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function () {
  var _this = this;

  // .reverse() is done in place and therefore mutating the queues array
  // so a copy is needed to prevent harmful side effects and general voodoo
  var reversedQueues = _this.queues.slice().reverse();

  var loop = function() {
    var emptyLoop = true;

    return Promise.each(reversedQueues, function(queue, index) {

      if(_this.closing){
        return _this.closing;
      }

      // the index is reversed to the actual priority number (0 is &#x27;critical&#x27;)
      // so flip it to get the correct &#x22;priority index&#x22;
      var nbJobsToProcess = _this.strategy(PriorityQueue.priorities.critical - index);
      var i = 0;

      var fn = function() {
        return queue.moveUnlockedJobsToWait().then(queue.getNextJob.bind(queue, {
            block: false
          }))
          .then(function(job) {
            if (job) {
              emptyLoop = false;
              return queue.processJob(job).then(function() {
                if (++i &#x3c; nbJobsToProcess &#x26;&#x26; !_this.paused) {
                  return fn();
                }
              })
            } else {
              //nothing It will release loop and call next priority queue even if we have no reach nbJobsToProcess
            }
          })
      }

      return fn();
    }).then(function() {
      if (!_this.paused) {
        return Promise.delay((emptyLoop) ? _this.waitAfterEmptyLoop : 0).then(loop);
      }
    });
  }

  return loop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

PriorityQueue.prototype.process = function(handler) {
this.handler = handler;
this.queues.forEach(function(queue, key) {
  queue.setHandler(handler);
});
return this.<span class="apidocCodeKeywordSpan">run</span>();
}

//
// TODO: Remove the polling mechanism using pub/sub.
//
PriorityQueue.prototype.run = function() {
var _this = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.priority_queue.prototype.setLockRenewTime" id="apidoc.element.bull.priority_queue.prototype.setLockRenewTime">
        function <span class="apidocSignatureSpan">bull.priority_queue.prototype.</span>setLockRenewTime
        <span class="apidocSignatureSpan">(lockRenewTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setLockRenewTime = function (lockRenewTime) {
  this.queues.forEach(function(queue) {
    queue.LOCK_RENEW_TIME = lockRenewTime;
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.queue" id="apidoc.module.bull.queue">module bull.queue</a></h1>


    <h2>
        <a href="#apidoc.element.bull.queue.queue" id="apidoc.element.bull.queue.queue">
        function <span class="apidocSignatureSpan">bull.</span>queue
        <span class="apidocSignatureSpan">(name, redisPort, redisHost, redisOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Queue(name, redisPort, redisHost, redisOptions){
  if(!(this instanceof Queue)){
    return new Queue(name, redisPort, redisHost, redisOptions);
  }

  if(_.isObject(redisPort)) {
    var opts = redisPort;
    var redisOpts = opts.redis || {};
    redisPort = redisOpts.port;
    redisHost = redisOpts.host;
    redisOptions = redisOpts.opts || {};
    redisOptions.db = redisOpts.DB || redisOpts.DB;
  } else if(parseInt(redisPort) == redisPort) {
    redisPort = parseInt(redisPort);
    redisOptions =  redisOptions || {};
  } else if(_.isString(redisPort)) {
    try {
      var redisUrl = url.parse(redisPort);
      assert(_.isObject(redisHost) || _.isUndefined(redisHost),
          &#x27;Expected an object as redis option&#x27;);
      redisOptions =  redisHost || {};
      redisPort = redisUrl.port;
      redisHost = redisUrl.hostname;
      if (redisUrl.auth) {
        redisOptions.password = redisUrl.auth.split(&#x27;:&#x27;)[1];
      }
    } catch (e) {
      throw new Error(e.message);
    }
  }

  redisOptions = redisOptions || {};

  function createClient(type) {
    var client;
    if(_.isFunction(redisOptions.createClient)){
      client = redisOptions.createClient(type);
    }else{
      client = new redis(redisPort, redisHost, redisOptions);
    }
    return client;
  }

  redisPort = redisPort || 6379;
  redisHost = redisHost || &#x27;127.0.0.1&#x27;;

  var _this = this;

  this.name = name;
  this.keyPrefix = redisOptions.keyPrefix || &#x27;bull&#x27;;

  //
  // We cannot use ioredis keyPrefix feature until we
  // stop creating keys dynamically in lua scripts.
  //
  delete redisOptions.keyPrefix;

  //
  // Create queue client (used to add jobs, pause queues, etc);
  //
  this.client = createClient(&#x27;client&#x27;);

  getRedisVersion(this.client).then(function(version){
    if(semver.lt(version, MINIMUM_REDIS_VERSION)){
      throw new Error(&#x27;Redis version needs to be greater than &#x27; + MINIMUM_REDIS_VERSION + &#x27;. Current: &#x27; + version);
    }
  }).catch(function(err){
    _this.emit(&#x27;error&#x27;, err);
  });

  //
  // Keep track of cluster clients for redlock
  //
  this.clients = [this.client];
  if (redisOptions.clients) {
    this.clients.push.apply(this.clients, redisOptions.clients);
  }
  this.redlock = {
    driftFactor: REDLOCK_DRIFT_FACTOR,
    retryCount: REDLOCK_RETRY_COUNT,
    retryDelay: REDLOCK_RETRY_DELAY
  };
  _.extend(this.redlock, redisOptions.redlock || {});

  //
  // Create blocking client (used to wait for jobs)
  //
  this.bclient = createClient(&#x27;block&#x27;);

  //
  // Create event subscriber client (receive messages from other instance of the queue)
  //
  this.eclient = createClient(&#x27;subscriber&#x27;);

  this.delayTimer = null;
  this.processing = 0;
  this.retrieving = 0;

  this.LOCK_RENEW_TIME = LOCK_RENEW_TIME;
  this.LOCK_DURATION = LOCK_DURATION;
  this.STALLED_JOB_CHECK_INTERVAL = STALLED_JOB_CHECK_INTERVAL;
  this.MAX_STALLED_JOB_COUNT = MAX_STALLED_JOB_COUNT;

  // bubble up Redis error events
  [this.client, this.bclient, this.eclient].forEach(function (client) {
    client.on(&#x27;error&#x27;, _this.emit.bind(_this, &#x27;error&#x27;));
  });

  // keeps track of active timers. used by close() to
  // ensure that disconnect() is deferred until all
  // scheduled redis commands have been executed
  this.timers = new TimerManager();

  // emit ready when redis connections ready
  var initializers = [this.client, this.bclient, this.eclient].map(function (client) {
    return new Promise(function(resolve, reject) {
      client.once(&#x27;ready&#x27;, resolve);
      client.once(&#x27;error&#x27;, reject);
    });
  });

  this._initializing = Promise.all(initializers).then(function(){
    return Promise.join(
      _this.eclient.subscribe(_this.toKey(&#x27;delayed&#x27;)),
      _this.eclient.subscribe(_this.toKey(&#x27;paused&#x27;))
    );
  }).then(function(){
    debuglog(name + &#x27; queue ready&#x27;);
    _this.emit(&#x27;ready&#x27;);
  }, function(err){
    console.error(&#x27;Error initializing queue:&#x27;, err);
  });

  Disturbed.call(this, _this.client, _this.eclient);

  //
  // Listen distributed queue events
  //
  listenDistEvent(&#x27;stalled&#x27;); //
  listenDistEvent(&#x27;active&#x27;); //
  listenDist ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.super_" id="apidoc.element.bull.queue.super_">
        function <span class="apidocSignatureSpan">bull.queue.</span>super_
        <span class="apidocSignatureSpan">(pubClient, subClient)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (pubClient, subClient) {
  var _this = this;
  EventEmitter.call(this);

  this.uuid = uuid();
  this.pubClient = pubClient;
  this.subClient = subClient;

  subClient.on(&#x27;message&#x27;, function (channel, msg) {

    var count = _this.listenerCount(channel);
    if (count) {
      var args;
      try {
        args = JSON.parse(msg);
      } catch (err) {
        console.error(&#x27;Parsing event message&#x27;, err);
      }

      if (args[0] !== _this.uuid) {
        args[0] = channel;
        _this.emit.apply(_this, args);
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.queue.prototype" id="apidoc.module.bull.queue.prototype">module bull.queue.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bull.queue.prototype.add" id="apidoc.element.bull.queue.prototype.add">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>add
        <span class="apidocSignatureSpan">(data, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (data, opts){
  return Job.create(this, data, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

pdfQueue.process(function(job){
  // Processors can also return promises instead of using the done callback
  return pdfAsyncProcessor();
});

videoQueue.<span class="apidocCodeKeywordSpan">add</span>({video: &#x27;http://example.com/video1.mov&#x27;});
audioQueue.add({audio: &#x27;http://example.com/audio1.mp3&#x27;});
imageQueue.add({image: &#x27;http://example.com/image1.tiff&#x27;});
```

Alternatively, you can use return promises instead of using the `done` callback:

```javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.clean" id="apidoc.element.bull.queue.prototype.clean">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>clean
        <span class="apidocSignatureSpan">(grace, type, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clean = function (grace, type, limit) {
  var _this = this;

  return new Promise(function (resolve, reject) {
    if(grace === undefined || grace === null) {
      return reject(new Error(&#x27;You must define a grace period.&#x27;));
    }

    if(!type) {
      type = &#x27;completed&#x27;;
    }

    if(_.indexOf([
      &#x27;completed&#x27;,
      &#x27;wait&#x27;,
      &#x27;active&#x27;,
      &#x27;delayed&#x27;,
      &#x27;failed&#x27;], type) === -1){
      return reject(new Error(&#x27;Cannot clean unkown queue type&#x27;));
    }

    return scripts.cleanJobsInSet(_this, type, Date.now() - grace, limit).then(function (jobs) {
      _this.distEmit(&#x27;cleaned&#x27;, jobs, type);
      resolve(jobs);
      return null;
    }).catch(function (err) {
      _this.emit(&#x27;error&#x27;, err);
      reject(err);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Tells the queue remove jobs of a specific type created outside of a grace period.

__Example__

```javascript
//cleans all jobs that completed over 5 seconds ago.
queue.<span class="apidocCodeKeywordSpan">clean</span>(5000);
//clean all jobs that failed over 10 seconds ago.
queue.clean(10000, &#x27;failed&#x27;);
queue.on(&#x27;cleaned&#x27;, function (job, type) {
  console.log(&#x27;Cleaned %s %s jobs&#x27;, job.length, type);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.close" id="apidoc.element.bull.queue.prototype.close">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>close
        <span class="apidocSignatureSpan">( doNotWaitJobs )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function ( doNotWaitJobs ){
  var _this = this;

  if(this.closing){
    return this.closing;
  }


  return this.closing = this._initializing.then(function(){
    clearTimeout(_this.delayTimer);
    clearInterval(_this.guardianTimer);
    clearInterval(_this.moveUnlockedJobsToWaitInterval);
    _this.timers.clearAll();

    return _this.timers.whenIdle().then(function(){
      return _this.pause(true, doNotWaitJobs);
    }).then(function(){
      return _this.disconnect();
    }).then(function(){
      _this.closed = true;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
shutdown.

```javascript
var Queue = require(&#x27;bull&#x27;);
var queue = Queue(&#x27;example&#x27;);

var after100 = _.after(100, function () {
  queue.<span class="apidocCodeKeywordSpan">close</span>().then(function () { console.log(&#x27;done&#x27;) })
});

queue.on(&#x27;completed&#x27;, after100);
```

`close` can be called from anywhere, with one caveat: if called
from within a job handler the queue won&#x27;t close until *after*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.count" id="apidoc.element.bull.queue.prototype.count">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>count
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (){
  var multi = this.multi();
  multi.llen(this.toKey(&#x27;wait&#x27;));
  multi.llen(this.toKey(&#x27;paused&#x27;));
  multi.zcard(this.toKey(&#x27;delayed&#x27;));

  return multi.exec().then(function(res){
    return Math.max(res[0][1], res[1][1]) + res[2][1];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Promise.resolve(jobs);
});
}


PriorityQueue.prototype.count = function() {
return Promise.map(this.queues, function(queue) {
  return queue.<span class="apidocCodeKeywordSpan">count</span>();
}).then(function(results) {
  var sum = 0;
  results.forEach(function(val) {
    sum += val;
  });
  return sum;
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.disconnect" id="apidoc.element.bull.queue.prototype.disconnect">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (){
  var _this = this;

  function endClients(){
    var timeoutMsg = &#x27;Timed out while waiting for redis clients to close&#x27;;

    return new Promise(function(resolve) {
      _this.bclient.end(true);
      _this.bclient.stream.once(&#x27;close&#x27;, resolve);
    }).timeout(CLIENT_CLOSE_TIMEOUT_MS, timeoutMsg)
    .catch(function(err){
      if(!(err instanceof Promise.TimeoutError)){
        throw err;
      }
    });
  }

  return Promise.join(
    _this.client.quit(),
    _this.eclient.quit()
  ).then(endClients, endClients);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @type {number}
 */
PriorityQueue.prototype.waitAfterEmptyLoop = 200;

PriorityQueue.prototype.disconnect = function() {
return Promise.map(this.queues, function(queue) {
  return queue.<span class="apidocCodeKeywordSpan">disconnect</span>();
})
}

PriorityQueue.prototype.close = function( doNotWaitJobs ) {
return this.closing = Promise.map(this.queues, function(queue) {
  return queue.close( doNotWaitJobs );
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.distEmit" id="apidoc.element.bull.queue.prototype.distEmit">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>distEmit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distEmit = function (){
  var args = Array.prototype.slice.call(arguments);

   // Emit local event
  this.emit.apply(this, args);

  // Emit global event
  args[0] = args[0] + &#x27;@&#x27; + this.name;
  return Disturbed.prototype.distEmit.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Job.create = function(queue, data, opts){
var job = new Job(queue, data, opts);

return addJob(queue, job).then(function(jobId){
  job.jobId = jobId;
  queue.<span class="apidocCodeKeywordSpan">distEmit</span>(&#x27;waiting&#x27;, job.toJSON());
  debuglog(&#x27;Job added&#x27;, jobId);
  return job;
});
};

Job.fromId = function(queue, jobId){
// jobId can be undefined if moveJob returns undefined
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.empty" id="apidoc.element.bull.queue.prototype.empty">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (){
  var _this = this;

  // Get all jobids and empty all lists atomically.
  var multi = this.multi();

  multi.lrange(this.toKey(&#x27;wait&#x27;), 0, -1);
  multi.lrange(this.toKey(&#x27;paused&#x27;), 0, -1);
  multi.del(this.toKey(&#x27;wait&#x27;));
  multi.del(this.toKey(&#x27;paused&#x27;));
  multi.del(this.toKey(&#x27;meta-paused&#x27;));
  multi.del(this.toKey(&#x27;delayed&#x27;));

  return multi.exec().spread(function(waiting, paused){
    waiting = waiting[1];
    paused = paused[1];
    var jobKeys = (paused.concat(waiting)).map(_this.toKey, _this);

    if(jobKeys.length){
      multi = _this.multi();

      multi.del.apply(multi, jobKeys);
      return multi.exec();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

PriorityQueue.prototype.add = function(data, opts) {
return this.getQueue(opts &#x26;&#x26; opts.priority).add(data, opts);
}

PriorityQueue.prototype.empty = function() {
return Promise.map(this.queues, function(queue) {
  return queue.<span class="apidocCodeKeywordSpan">empty</span>();
});
}

PriorityQueue.prototype.pause = function(localOnly) {
var _this = this;

_this.paused = Promise.map(this.queues, function(queue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getActive" id="apidoc.element.bull.queue.prototype.getActive">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getActive = function (){
  return this.getJobs(&#x27;active&#x27;, &#x27;LIST&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getActiveCount" id="apidoc.element.bull.queue.prototype.getActiveCount">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getActiveCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getActiveCount = function () {
  return this.client.llen(this.toKey(&#x27;active&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getCompleted" id="apidoc.element.bull.queue.prototype.getCompleted">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getCompleted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCompleted = function (){
  return this.getJobs(&#x27;completed&#x27;, &#x27;SET&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getCompletedCount" id="apidoc.element.bull.queue.prototype.getCompletedCount">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getCompletedCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCompletedCount = function () {
  return this.client.scard(this.toKey(&#x27;completed&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getDelayed" id="apidoc.element.bull.queue.prototype.getDelayed">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getDelayed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDelayed = function (){
  return this.getJobs(&#x27;delayed&#x27;, &#x27;ZSET&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getDelayedCount" id="apidoc.element.bull.queue.prototype.getDelayedCount">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getDelayedCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDelayedCount = function () {
  return this.client.zcard(this.toKey(&#x27;delayed&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getFailed" id="apidoc.element.bull.queue.prototype.getFailed">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getFailed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFailed = function (){
  return this.getJobs(&#x27;failed&#x27;, &#x27;SET&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getFailedCount" id="apidoc.element.bull.queue.prototype.getFailedCount">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getFailedCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFailedCount = function () {
  return this.client.scard(this.toKey(&#x27;failed&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getJob" id="apidoc.element.bull.queue.prototype.getJob">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJob
        <span class="apidocSignatureSpan">(jobId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJob = function (jobId){
  return Job.fromId(this, jobId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getJobCountByTypes" id="apidoc.element.bull.queue.prototype.getJobCountByTypes">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobCountByTypes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJobCountByTypes = function () {
  var _this = this;
  var args = _.compact(Array.prototype.slice.call(arguments));
  var types = _.compact(args.join(&#x27;,&#x27;).replace(/ /g, &#x27;&#x27;).split(&#x27;,&#x27;));

  var multi = this.multi();

  _.each(types, function(type) {
    var key = _this.toKey(type);
    switch(type) {
      case &#x27;completed&#x27;:
      case &#x27;failed&#x27;:
        multi.scard(key);
        break;
      case &#x27;delayed&#x27;:
        multi.zcard(key);
        break;
      case &#x27;active&#x27;:
      case &#x27;wait&#x27;:
      case &#x27;paused&#x27;:
        multi.llen(key);
        break;
    }
  });

  return multi.exec().then(function(res){
    return res.map(function(v) {
      return v[1]
    }).reduce(function(a, b) {
      return a + b
    });	
  }) || 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getJobCounts" id="apidoc.element.bull.queue.prototype.getJobCounts">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobCounts
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJobCounts = function (){
  var types = [&#x27;wait&#x27;, &#x27;active&#x27;, &#x27;completed&#x27;, &#x27;failed&#x27;, &#x27;delayed&#x27;];
  var counts = {};
  return this.client.multi()
    .llen(this.toKey(&#x27;wait&#x27;))
    .llen(this.toKey(&#x27;active&#x27;))
    .scard(this.toKey(&#x27;completed&#x27;))
    .scard(this.toKey(&#x27;failed&#x27;))
    .zcard(this.toKey(&#x27;delayed&#x27;))
    .exec().then(function(result){
      result.forEach(function(res, index){
        counts[types[index]] = res[1] || 0;
      });
      return counts;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getJobMoveCount" id="apidoc.element.bull.queue.prototype.getJobMoveCount">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobMoveCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJobMoveCount = function (){
  return this.bclient.commandQueue.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getJobs" id="apidoc.element.bull.queue.prototype.getJobs">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getJobs
        <span class="apidocSignatureSpan">(queueType, type, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJobs = function (queueType, type, start, end){
  var _this = this;
  var key = this.toKey(queueType);
  var jobs;

  start = _.isUndefined(start) ? 0 : start;
  end = _.isUndefined(end) ? -1 : end;

  switch(type){
    case &#x27;LIST&#x27;:
      jobs = this.client.lrange(key, start, end);
      break;
    case &#x27;SET&#x27;:
      jobs = this.client.smembers(key).then(function(jobIds) {
        // Can&#x27;t set a range for smembers. So do the slice programatically instead.
        // Note that redis ranges are inclusive, so handling for javascript accordingly
        if (end === -1) {
          return jobIds.slice(start);
        }

        return jobIds.slice(start, end + 1);
      });
      break;
    case &#x27;ZSET&#x27;:
      jobs = this.client.zrange(key, start, end);
      break;
  }

  return jobs.then(function(jobIds){
    var jobsFromId = jobIds.map(_this.getJobFromId);
    return Promise.all(jobsFromId);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getNextJob" id="apidoc.element.bull.queue.prototype.getNextJob">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getNextJob
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNextJob = function (opts){
  var _this = this;
  if(!this.closing){
    this.retrieving++;
    return this.moveJob(&#x27;wait&#x27;, &#x27;active&#x27;, opts)
      .then(this.getJobFromId)
      .tap(function(job) {
        _this.retrieving--;
        if (job) {
          _this.processing++;
        } else {
          _this.emit(&#x27;no-job-retrieved&#x27;);
        }
      })
      .catch(function(err) {
        _this.retrieving--;
        _this.emit(&#x27;no-job-retrieved&#x27;);
        throw err;
      });
  }else{
    return Promise.reject();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getPausedCount" id="apidoc.element.bull.queue.prototype.getPausedCount">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getPausedCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPausedCount = function () {
  return this.client.llen(this.toKey(&#x27;paused&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getWaiting" id="apidoc.element.bull.queue.prototype.getWaiting">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getWaiting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWaiting = function (){
  return Promise.join(
    this.getJobs(&#x27;wait&#x27;, &#x27;LIST&#x27;),
    this.getJobs(&#x27;paused&#x27;, &#x27;LIST&#x27;)).spread(function(waiting, paused){
      return _.concat(waiting, paused);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.getWaitingCount" id="apidoc.element.bull.queue.prototype.getWaitingCount">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>getWaitingCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getWaitingCount = function () {
  return this.client.llen(this.toKey(&#x27;wait&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.isReady" id="apidoc.element.bull.queue.prototype.isReady">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>isReady
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isReady = function (){
  var _this = this;
  return this._initializing.then(function(){
    return _this;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.moveJob" id="apidoc.element.bull.queue.prototype.moveJob">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>moveJob
        <span class="apidocSignatureSpan">(src, dst, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveJob = function (src, dst, opts) {
  var args = arguments;
  var _this = this;
  var move;
  if(opts &#x26;&#x26; opts.block === false){
    if(!this.closing){
      move = this.bclient.rpoplpush(this.toKey(src), this.toKey(dst));
    }else{
      move = Promise.reject();
    }
  } else if (this.closing || this.paused) {
    move = Promise.resolve();
  } else if (this.getJobMoveCount()) {
    move = this.whenCurrentMoveFinished().then(function() {
      return _this.moveJob.apply(_this, args);
    });
  }else{
    move = this.bclient.brpoplpush(
      this.toKey(src),
      this.toKey(dst),
      Math.floor(this.LOCK_RENEW_TIME / 1000));
  }

  return move.then(function(jobId){
    //
    // Unfortunatelly this cannot be performed atomically, which will lead to a
    // slight hazard for priority queues (will only affect its order).
    //
    if(jobId){
      return _this.client.zrem(_this.toKey(&#x27;priority&#x27;), jobId).then(function(){
        return jobId;
      });
    }
  }, function(err){
    if(!_this.closing){
      throw err;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.moveUnlockedJobsToWait" id="apidoc.element.bull.queue.prototype.moveUnlockedJobsToWait">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>moveUnlockedJobsToWait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveUnlockedJobsToWait = function (){
  var _this = this;

  return scripts.moveUnlockedJobsToWait(this).then(function(responses){
    var handleFailedJobs = responses[0].map(function(jobId){
      return _this.getJobFromId(jobId).then(function(job){
        _this.distEmit(&#x27;failed&#x27;, job, new Error(&#x27;job stalled more than allowable limit&#x27;));
        return null;
      });
    });
    var handleStalledJobs = responses[1].map(function(jobId){
      return _this.getJobFromId(jobId).then(function(job){
        _this.distEmit(&#x27;stalled&#x27;, job);
        return null;
      });
    });
    return Promise.all(handleFailedJobs.concat(handleStalledJobs));
  }).catch(function(err){
    console.error(&#x27;Failed to handle unlocked job in active:&#x27;, err);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// the index is reversed to the actual priority number (0 is &#x27;critical&#x27;)
// so flip it to get the correct &#x22;priority index&#x22;
var nbJobsToProcess = _this.strategy(PriorityQueue.priorities.critical - index);
var i = 0;

var fn = function() {
  return queue.<span class="apidocCodeKeywordSpan">moveUnlockedJobsToWait</span>().then(queue.getNextJob.bind(queue, {
      block: false
    }))
    .then(function(job) {
      if (job) {
        emptyLoop = false;
        return queue.processJob(job).then(function() {
          if (++i &#x3c; nbJobsToProcess &#x26;&#x26; !_this.paused) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.multi" id="apidoc.element.bull.queue.prototype.multi">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>multi
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multi = function (){
  return this.client.multi();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/*
Queue.prototype.empty = function(){
var _this = this;

// Get all jobids and empty all lists atomically.
var multi = this.<span class="apidocCodeKeywordSpan">multi</span>();

multi.lrange(this.toKey(&#x27;wait&#x27;), 0, -1);
multi.lrange(this.toKey(&#x27;paused&#x27;), 0, -1);
multi.del(this.toKey(&#x27;wait&#x27;));
multi.del(this.toKey(&#x27;paused&#x27;));
multi.del(this.toKey(&#x27;meta-paused&#x27;));
multi.del(this.toKey(&#x27;delayed&#x27;));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.on" id="apidoc.element.bull.queue.prototype.on">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (){
  var args = Array.prototype.slice.call(arguments);
  var promise = Disturbed.prototype.on.apply(this, args);
  var _this = this;
  promise.catch(function(err){ _this.emit(&#x27;error&#x27;, err); });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
queue.resume().then(function(){
  // queue is resumed now
})
```

A queue emits also some useful events:
```javascript
.<span class="apidocCodeKeywordSpan">on</span>(&#x27;ready&#x27;, function() {
  // Queue ready for job
  // All Redis connections are done
})
.on(&#x27;error&#x27;, function(error) {
  // Error
})
.on(&#x27;active&#x27;, function(job, jobPromise){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.once" id="apidoc.element.bull.queue.prototype.once">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (){
  var args = Array.prototype.slice.call(arguments);
  Disturbed.prototype.once.apply(this, args);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.queues[PriorityQueue.priorities[key]] = queue;
}

var groupEvents = [&#x27;ready&#x27;, &#x27;paused&#x27;, &#x27;resumed&#x27;]
groupEvents.forEach(function(event) {
  Promise.map(_this.queues, function(queue) {
    return new Promise(function(resolve, reject) {
      queue.<span class="apidocCodeKeywordSpan">once</span>(event, resolve);
    });
  }).then(_this.emit.bind(_this, event))
})

var singleEvents = [&#x27;error&#x27;, &#x27;active&#x27;, &#x27;stalled&#x27;, &#x27;progress&#x27;, &#x27;completed&#x27;, &#x27
;failed&#x27;, &#x27;cleaned&#x27;]
singleEvents.forEach(function(event) {
  _this.queues.forEach(function(queue) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.pause" id="apidoc.element.bull.queue.prototype.pause">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>pause
        <span class="apidocSignatureSpan">(isLocal, doNotWaitActive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function (isLocal, doNotWaitActive){
  if(isLocal){
    var _this = this;

    if(!this.paused){
      this.paused = new Promise(function(resolve) {
        _this.resumeLocal = function() {
          resolve();
          _this.paused = null; // Allow pause to be checked externally for paused state.
        };
      });
    }

    return !doNotWaitActive &#x26;&#x26; this.whenCurrentJobsFinished();
  }else{
    return pauseResumeGlobal(this, true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Promise.reject(new Error(&#x27;some unexpected error&#x27;));
});
```

A queue can be paused and resumed globally (pass `true` to pause processing for
just this worker):
```javascript
queue.<span class="apidocCodeKeywordSpan">pause</span>().then(function(){
  // queue is paused now
});

queue.resume().then(function(){
  // queue is resumed now
})
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.process" id="apidoc.element.bull.queue.prototype.process">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>process
        <span class="apidocSignatureSpan">(concurrency, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">process = function (concurrency, handler){
  var _this = this;
  if(typeof concurrency === &#x27;function&#x27;){
    handler = concurrency;
    concurrency = 1;
  }

  this.setHandler(handler);

  var runQueueWhenReady = function(){
    _this.bclient.once(&#x27;ready&#x27;, function(){
      _this.run(concurrency).catch(function(err){
        console.error(err);
      });
    });
  };

  // attempt to restart the queue when the client throws
  // an error or the connection is dropped by redis
  this.bclient.on(&#x27;error&#x27;, runQueueWhenReady);
  this.bclient.on(&#x27;end&#x27;, runQueueWhenReady);

  return this.run(concurrency).catch(function(err){
    console.error(err);
    throw err;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Queue = require(&#x27;bull&#x27;);

var videoQueue = Queue(&#x27;video transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);
var audioQueue = Queue(&#x27;audio transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);
var imageQueue = Queue(&#x27;image transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);
var pdfQueue = Queue(&#x27;pdf transcoding&#x27;, 6379, &#x27;127.0.0.1&#x27;);

videoQueue.<span class="apidocCodeKeywordSpan">process</span>(function(job, done){

// job.data contains the custom data passed when the job was created
// job.jobId contains id of this job.

// transcode video asynchronously and report progress
job.progress(42);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.processJob" id="apidoc.element.bull.queue.prototype.processJob">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>processJob
        <span class="apidocSignatureSpan">(job)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processJob = function (job){
  var _this = this;
  var lockRenewId;
  var timmerStopped = false;

  if(!job){
    return Promise.resolve();
  }

  //
  // TODO:
  // There are two cases to take into consideration regarding locks.
  // 1) The lock renewer fails to renew a lock, this should make this job
  // unable to complete, since some other worker is also working on it.
  // 2) The lock renewer is called more seldom than the check for stalled
  // jobs, so we can assume the job has been stalled and is already being processed
  // by another worker. See #308
  //
  var renew = false;
  var lockRenewer = function(){
    return job.takeLock(renew, true).then(function(lock){
      if(lock &#x26;&#x26; !timmerStopped){
        renew = true;
        lockRenewId = _this.timers.set(&#x27;lockRenewer&#x27;, _this.LOCK_RENEW_TIME, lockRenewer);
      }
      // TODO: if we failed to re-acquire the lock while trying to renew, should we let the job
      // handler know and cancel the timer?
      return lock;
    }, function(err){
      console.error(&#x27;Error renewing lock &#x27; + err);
    });
  };

  var timeoutMs = job.opts.timeout;

  function stopTimer(){
    timmerStopped = true;
    _this.timers.clear(lockRenewId);
    return Promise.resolve();
  }

  function handleCompleted(data){
    try{
      JSON.stringify(data);
    }catch(err){
      return handleFailed(err);
    }
    // This substraction is duplicate in handleCompleted and handleFailed because it have to be made before throwing any
    // event completed or failed in order to allow pause() to work correctly without getting stuck.
    _this.processing--;

    stopTimer();

    if(_this.closed){
      return;
    }

    return job.moveToCompleted(data).then(function(){
      return _this.distEmit(&#x27;completed&#x27;, job, data);
    });
  }

  function handleFailed(err){
    var error = err.cause || err; //Handle explicit rejection

    // TODO: Should moveToFailed ensure the lock atomically in one of its Lua scripts?
    // See https://github.com/OptimalBits/bull/pull/415#issuecomment-269744735
    job.takeLock(true /* renwew */, false /* ensureActive */).then( function(lock) {
      return stopTimer()
        .then(job.moveToFailed(err))
        .then(job.releaseLock.bind(job))
        .then(function(){
          return _this.distEmit(&#x27;failed&#x27;, job, error);
        });
    }, function(err){
      console.error(&#x27;failed to re-obtain lock before moving to failed, bailing: &#x27;, err);
      stopTimer();
    });
    _this.processing--;
  }

  return lockRenewer().then(function(locked){
    if(locked){
      var jobPromise = _this.handler(job);

      if(timeoutMs){
        jobPromise = jobPromise.timeout(timeoutMs);
      }

      _this.distEmit(&#x27;active&#x27;, job, jobPromise);

      return jobPromise
        .then(handleCompleted, handleFailed);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var fn = function() {
return queue.moveUnlockedJobsToWait().then(queue.getNextJob.bind(queue, {
    block: false
  }))
  .then(function(job) {
    if (job) {
      emptyLoop = false;
      return queue.<span class="apidocCodeKeywordSpan">processJob</span>(job).then(function() {
        if (++i &#x3c; nbJobsToProcess &#x26;&#x26; !_this.paused) {
          return fn();
        }
      })
    } else {
      //nothing It will release loop and call next priority queue even if we have no reach nbJobsToProcess
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.processJobs" id="apidoc.element.bull.queue.prototype.processJobs">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>processJobs
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">processJobs = function (resolve, reject){
  var _this = this;
  var processJobs = this.processJobs.bind(this, resolve, reject);

  if(!this.closing){
    process.nextTick(function(){
      (_this.paused || Promise.resolve())
        .then(_this.getNextJob)
        .then(_this.processJob)
        .then(processJobs, function(err){
          console.error(&#x27;Error processing job:&#x27;, err);
          processJobs();
        }).catch(reject);
    });
  }else{
    resolve(this.closing);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.resume" id="apidoc.element.bull.queue.prototype.resume">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>resume
        <span class="apidocSignatureSpan">(isLocal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function (isLocal){
  if(isLocal){
    if(this.resumeLocal){
      this.resumeLocal();
    }
    return Promise.resolve();
  }else{
    return pauseResumeGlobal(this, false);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A queue can be paused and resumed globally (pass `true` to pause processing for
just this worker):
```javascript
queue.pause().then(function(){
  // queue is paused now
});

queue.<span class="apidocCodeKeywordSpan">resume</span>().then(function(){
  // queue is resumed now
})
```

A queue emits also some useful events:
```javascript
.on(&#x27;ready&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.retryJob" id="apidoc.element.bull.queue.prototype.retryJob">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>retryJob
        <span class="apidocSignatureSpan">(job)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryJob = function (job) {
  return job.retry();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.run" id="apidoc.element.bull.queue.prototype.run">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>run
        <span class="apidocSignatureSpan">(concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">run = function (concurrency){
  var promises = [];
  var _this = this;

  return this.moveUnlockedJobsToWait().then(function(){

    while(concurrency--){
      promises.push(new Promise(_this.processJobs));
    }

    _this.startMoveUnlockedJobsToWait();

    return Promise.all(promises);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

PriorityQueue.prototype.process = function(handler) {
this.handler = handler;
this.queues.forEach(function(queue, key) {
  queue.setHandler(handler);
});
return this.<span class="apidocCodeKeywordSpan">run</span>();
}

//
// TODO: Remove the polling mechanism using pub/sub.
//
PriorityQueue.prototype.run = function() {
var _this = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.setHandler" id="apidoc.element.bull.queue.prototype.setHandler">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>setHandler
        <span class="apidocSignatureSpan">(handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHandler = function (handler){
  if(this.handler) {
    throw new Error(&#x27;Cannot define a handler more than once per Queue instance&#x27;);
  }

  handler = handler.bind(this);

  if(handler.length &#x3e; 1){
    this.handler = Promise.promisify(handler);
  }else{
    this.handler = Promise.method(handler);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return queue.close( doNotWaitJobs );
  });
}

PriorityQueue.prototype.process = function(handler) {
  this.handler = handler;
  this.queues.forEach(function(queue, key) {
    queue.<span class="apidocCodeKeywordSpan">setHandler</span>(handler);
  });
  return this.run();
}

//
// TODO: Remove the polling mechanism using pub/sub.
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.startMoveUnlockedJobsToWait" id="apidoc.element.bull.queue.prototype.startMoveUnlockedJobsToWait">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>startMoveUnlockedJobsToWait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startMoveUnlockedJobsToWait = function () {
  if (this.STALLED_JOB_CHECK_INTERVAL &#x3e; 0){
    clearInterval(this.moveUnlockedJobsToWaitInterval);
    this.moveUnlockedJobsToWaitInterval =
      setInterval(this.moveUnlockedJobsToWait, this.STALLED_JOB_CHECK_INTERVAL);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.toKey" id="apidoc.element.bull.queue.prototype.toKey">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>toKey
        <span class="apidocSignatureSpan">(queueType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKey = function (queueType){
  return [this.keyPrefix, this.name, queueType].join(&#x27;:&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Job.fromId = function(queue, jobId){
  // jobId can be undefined if moveJob returns undefined
  if(!jobId) {
    return Promise.resolve();
  }
  return queue.client.hgetall(queue.<span class="apidocCodeKeywordSpan">toKey</span>(jobId)).then(function(jobData){
    if(!_.isEmpty(jobData)){
      return Job.fromData(queue, jobId, jobData);
    }else{
      return null;
    }
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.updateDelayTimer" id="apidoc.element.bull.queue.prototype.updateDelayTimer">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>updateDelayTimer
        <span class="apidocSignatureSpan">(newDelayedTimestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateDelayTimer = function (newDelayedTimestamp){
  var _this = this;

  if(newDelayedTimestamp &#x3c; _this.delayedTimestamp &#x26;&#x26; newDelayedTimestamp &#x3c; (MAX_TIMEOUT_MS + Date.now())){
    clearTimeout(this.delayTimer);
    this.delayedTimestamp = newDelayedTimestamp;

    var nextDelayedJob = newDelayedTimestamp - Date.now();
    nextDelayedJob = nextDelayedJob &#x3c; 0 ? 0 : nextDelayedJob;

    this.delayTimer = setTimeout(function(){
      scripts.updateDelaySet(_this, _this.delayedTimestamp).then(function(nextTimestamp){
        if(nextTimestamp){
          nextTimestamp = nextTimestamp &#x3c; Date.now() ? Date.now() : nextTimestamp;
        }else{
          nextTimestamp = Number.MAX_VALUE;
        }
        _this.updateDelayTimer(nextTimestamp);
      }).catch(function(err){
        console.error(&#x27;Error updating the delay timer&#x27;, err);
      });
      _this.delayedTimestamp = Number.MAX_VALUE;
    }, nextDelayedJob);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.whenCurrentJobsFinished" id="apidoc.element.bull.queue.prototype.whenCurrentJobsFinished">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>whenCurrentJobsFinished
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whenCurrentJobsFinished = function (){
  var _this = this;
  var resolver;
  var count = this.processing + this.retrieving;
  return new Promise(function(resolve) {
    if(count === 0){
      resolve();
    }else{
      resolver = _.after(count, function(){
        _this.removeListener(&#x27;stalled&#x27;, resolver);
        _this.removeListener(&#x27;completed&#x27;, resolver);
        _this.removeListener(&#x27;failed&#x27;, resolver);
        _this.removeListener(&#x27;no-job-retrieved&#x27;, resolver);
        clearInterval(_this.moveUnlockedJobsToWaitInterval);
        resolve();
      });

      _this.on(&#x27;stalled&#x27;, resolver);
      _this.on(&#x27;completed&#x27;, resolver);
      _this.on(&#x27;failed&#x27;, resolver);
      _this.on(&#x27;no-job-retrieved&#x27;, resolver);

      _this.startMoveUnlockedJobsToWait();
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.queue.prototype.whenCurrentMoveFinished" id="apidoc.element.bull.queue.prototype.whenCurrentMoveFinished">
        function <span class="apidocSignatureSpan">bull.queue.prototype.</span>whenCurrentMoveFinished
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whenCurrentMoveFinished = function (){
  var currentMove = this.bclient.commandQueue.peekFront()
  return currentMove &#x26;&#x26; currentMove.command.promise || Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.scripts" id="apidoc.module.bull.scripts">module bull.scripts</a></h1>


    <h2>
        <a href="#apidoc.element.bull.scripts._isJobInList" id="apidoc.element.bull.scripts._isJobInList">
        function <span class="apidocSignatureSpan">bull.scripts.</span>_isJobInList
        <span class="apidocSignatureSpan">(keyVar, argVar, operator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isJobInList = function (keyVar, argVar, operator) {
 	keyVar = keyVar || &#x27;KEYS[1]&#x27;;
  argVar = argVar || &#x27;ARGV[1]&#x27;;
  operator = operator || &#x27;return&#x27;;
  return [
    &#x27;local function item_in_list (list, item)&#x27;,
    &#x27;  for _, v in pairs(list) do&#x27;,
    &#x27;    if v == item then&#x27;,
    &#x27;      return 1&#x27;,
    &#x27;    end&#x27;,
    &#x27;  end&#x27;,
    &#x27;  return nil&#x27;,
    &#x27;end&#x27;,
    [&#x27;local items = redis.call(&#x22;LRANGE&#x22;,&#x27;, keyVar, &#x27; , 0, -1)&#x27;].join(&#x27;&#x27;),
    [operator, &#x27; item_in_list(items, &#x27;, argVar, &#x27;)&#x27;].join(&#x27;&#x27;)
  ].join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;  return nil&#x27;,
    &#x27;end&#x27;,
    [&#x27;local items = redis.call(&#x22;LRANGE&#x22;,&#x27;, keyVar, &#x27; , 0, -1)&#x27;].join(&#x27;&#x27;),
    [operator, &#x27; item_in_list(items, &#x27;, argVar, &#x27;)&#x27;].join(&#x27;&#x27;)
  ].join(&#x27;\n&#x27;);
},
isJobInList: function(client, listKey, jobId){
  return execScript(client, &#x27;isJobInList&#x27;, this.<span class="apidocCodeKeywordSpan">_isJobInList</span>(), 1, listKey,
jobId).then(function(result){
    return result === 1;
  });
},
addJob: function(client, toKey, job, opts){
  var delayed;
  var scriptName;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.addJob" id="apidoc.element.bull.scripts.addJob">
        function <span class="apidocSignatureSpan">bull.scripts.</span>addJob
        <span class="apidocSignatureSpan">(client, toKey, job, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addJob = function (client, toKey, job, opts){
  var delayed;
  var scriptName;

  opts = opts || {};
  opts.lifo = !!(opts.lifo);

  var delayTimestamp = job.timestamp + job.delay;
  if(job.delay &#x26;&#x26; delayTimestamp &#x3e; Date.now()){
    delayed = true;
    scriptName = &#x27;addJob:delayed&#x27;;
  } else {
    scriptName = &#x27;addJob&#x27;+(opts.lifo?&#x27;:lifo&#x27;:&#x27;&#x27;) + (opts.priority?&#x27;:priority&#x27;:&#x27;&#x27;);
  }

<span class="apidocCodeCommentSpan">  /*
  if(isCommandDefined(client, scriptName)){
    return client[scriptName].apply(client, args);
  };
  */
</span>
  var jobArgs = _.flatten(_.toPairs(job));

  var keys = _.map([&#x27;wait&#x27;, &#x27;paused&#x27;, &#x27;meta-paused&#x27;, &#x27;jobs&#x27;, &#x27;id&#x27;, &#x27;delayed&#x27;, &#x27;priority&#x27;], function(name){
    return toKey(name);
  });
  var baseKey = toKey(&#x27;&#x27;);

  var argvs = _.map(jobArgs, function(arg, index){
    return &#x27;, ARGV[&#x27;+(index+4)+&#x27;]&#x27;;
  })

  var script = [
    &#x27;local jobCounter = redis.call(&#x22;INCR&#x22;, KEYS[5])&#x27;,
    &#x27;local jobId&#x27;,
    &#x27;if ARGV[2] == &#x22;&#x22; then jobId = jobCounter else jobId = ARGV[2] end&#x27;,
    &#x27;local jobIdKey = ARGV[1] .. jobId&#x27;,
    &#x27;if redis.call(&#x22;EXISTS&#x22;, jobIdKey) == 1 then return jobId end&#x27;,
    &#x27;redis.call(&#x22;HMSET&#x22;, jobIdKey&#x27; + argvs.join(&#x27;&#x27;) + &#x27;)&#x27;,
  ];

  var delayTimestamp = job.timestamp + job.delay;
  if(delayed){
    script.push.apply(script, [
      &#x27; local timestamp = tonumber(ARGV[&#x27; + (argvs.length + 4) + &#x27;]) * 0x1000 + bit.band(jobCounter, 0xfff)&#x27;,
      &#x27; redis.call(&#x22;ZADD&#x22;, KEYS[6], timestamp, jobId)&#x27;,
      &#x27; redis.call(&#x22;PUBLISH&#x22;, KEYS[6], (timestamp / 0x1000))&#x27;,
      &#x27; return jobId&#x27;,
    ]);
  }else{
    var push, pushPaused;
    var add = _.template(&#x27;redis.call(&#x22;&#x3c;%= direction %&#x3e;&#x22;, &#x3c;%= waitQueue %&#x3e;, jobId)&#x27;);

    if(opts.lifo){
      push = add({direction: &#x27;RPUSH&#x27;, waitQueue: &#x27;KEYS[1]&#x27;});
      pushPaused = add({direction: &#x27;RPUSH&#x27;, waitQueue: &#x27;KEYS[2]&#x27;});
    }else if(opts.priority){
      script.push.apply(script, [
        &#x27; redis.call(&#x22;ZADD&#x22;, KEYS[7], ARGV[3], jobId)&#x27;,
        &#x27; local count = redis.call(&#x22;ZCOUNT&#x22;, KEYS[7], 0, ARGV[3])&#x27;,
      ]);

      var priorityAdd = _.template([
        &#x27; local len = redis.call(&#x22;LLEN&#x22;, &#x3c;%= waitQueue %&#x3e;)&#x27;,
        &#x27; local id = redis.call(&#x22;LINDEX&#x22;, &#x3c;%= waitQueue %&#x3e;, len - (count-1))&#x27;,
        &#x27; if id then&#x27;,
        &#x27;   redis.call(&#x22;LINSERT&#x22;, &#x3c;%= waitQueue %&#x3e;, &#x22;BEFORE&#x22;, id, jobId)&#x27;,
        &#x27; else&#x27;,
        &#x27;   redis.call(&#x22;RPUSH&#x22;, &#x3c;%= waitQueue %&#x3e;, jobId)&#x27;,
        &#x27; end&#x27;,
      ].join(&#x27;\n&#x27;));

      push = priorityAdd({waitQueue: &#x27;KEYS[1]&#x27;});
      pushPaused = priorityAdd({waitQueue: &#x27;KEYS[2]&#x27;});
    }else{
      push = add({direction: &#x27;LPUSH&#x27;, waitQueue: &#x27;KEYS[1]&#x27;});
      pushPaused = add({direction: &#x27;LPUSH&#x27;, waitQueue: &#x27;KEYS[2]&#x27;});
    }

    //
    // Whe check for the meta-paused key to decide if we are paused or not
    // (since an empty list and !EXISTS are not really the same)
    script.push.apply(script, [
      &#x27;if redis.call(&#x22;EXISTS&#x22;, KEYS[3]) ~= 1 then&#x27;,
      push,
      &#x27;else&#x27;,
      pushPaused,
      &#x27;end&#x27;,
      &#x27;redis.call(&#x22;PUBLISH&#x22;, KEYS[4], jobId)&#x27;,
      &#x27;return jobId .. &#x22;&#x22;&#x27;
    ]);
  }

  var args = [
    client,
    scriptName,
    script.join(&#x27;\n&#x27;),
    keys.length
  ];

  args.push.apply(args, keys);
  args.push(baseKey);
  args.push(opts.customJobId || &#x27;&#x27;);
  args.push(opts.priority);
  args.push.apply(args, jobArgs);
  args.push(delayTimestamp);

  return execScript.apply(scripts, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.attemptsMade = 0;
};

function addJob(queue, job){
  var opts = job.opts;
  var jobData = job.toData();
  var toKey = _.bind(queue.toKey, queue);
  return scripts.<span class="apidocCodeKeywordSpan">addJob</span>(queue.client, toKey, jobData, {
    lifo: opts.lifo,
    customJobId: opts.jobId,
    priority: opts.priority
  });
}

Job.create = function(queue, data, opts){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.cleanJobsInSet" id="apidoc.element.bull.scripts.cleanJobsInSet">
        function <span class="apidocSignatureSpan">bull.scripts.</span>cleanJobsInSet
        <span class="apidocSignatureSpan">(queue, set, ts, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanJobsInSet = function (queue, set, ts, limit) {
  var command;
  var removeCommand;
  var breakEarlyCommand = &#x27;&#x27;;
  var hash;
  limit = limit || 0;

  switch(set) {
    case &#x27;completed&#x27;:
    case &#x27;failed&#x27;:
      command = &#x27;local jobs = redis.call(&#x22;SMEMBERS&#x22;, KEYS[1])&#x27;;
      removeCommand = &#x27;redis.call(&#x22;SREM&#x22;, KEYS[1], job)&#x27;;
      hash = &#x27;cleanSet&#x27;;
      break;
    case &#x27;wait&#x27;:
    case &#x27;active&#x27;:
    case &#x27;paused&#x27;:
      command = &#x27;local jobs = redis.call(&#x22;LRANGE&#x22;, KEYS[1], 0, -1)&#x27;;
      removeCommand = &#x27;redis.call(&#x22;LREM&#x22;, KEYS[1], 0, job)&#x27;;
      hash = &#x27;cleanList&#x27;;
      break;
    case &#x27;delayed&#x27;:
      command = &#x27;local jobs = redis.call(&#x22;ZRANGE&#x22;, KEYS[1], 0, -1)&#x27;;
      removeCommand = &#x27;redis.call(&#x22;ZREM&#x22;, KEYS[1], job)&#x27;;
      hash = &#x27;cleanOSet&#x27;;
      break;
  }

  if(limit &#x3e; 0) {
    breakEarlyCommand = [
      &#x27;if deletedCount &#x3e;= limit then&#x27;,
      &#x27;  break&#x27;,
      &#x27;end&#x27;,
    ].join(&#x27;\n&#x27;);

    hash = hash + &#x27;WithLimit&#x27;;
  }

  var script = [
    command,
    &#x27;local deleted = {}&#x27;,
    &#x27;local deletedCount = 0&#x27;,
    &#x27;local limit = tonumber(ARGV[3])&#x27;,
    &#x27;local jobTS&#x27;,
    &#x27;for _, job in ipairs(jobs) do&#x27;,
    breakEarlyCommand,
    &#x27;  local jobKey = ARGV[1] .. job&#x27;,
    &#x27;  if (redis.call(&#x22;EXISTS&#x22;, jobKey ..  &#x22;:lock&#x22;) == 0) then&#x27;,
    &#x27;    jobTS = redis.call(&#x22;HGET&#x22;, jobKey, &#x22;timestamp&#x22;)&#x27;,
    &#x27;    if(not jobTS or jobTS &#x3c; ARGV[2]) then&#x27;,
    removeCommand,
    &#x27;      redis.call(&#x22;DEL&#x22;, jobKey)&#x27;,
    &#x27;      deletedCount = deletedCount + 1&#x27;,
    &#x27;      table.insert(deleted, job)&#x27;,
    &#x27;    end&#x27;,
    &#x27;  end&#x27;,
    &#x27;end&#x27;,
    &#x27;return deleted&#x27;
  ].join(&#x27;\n&#x27;);

  var args = [
    queue.client,
    hash,
    script,
    1,
    queue.toKey(set),
    queue.toKey(&#x27;&#x27;),
    ts,
    limit
  ];

  return execScript.apply(scripts, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.isJobInList" id="apidoc.element.bull.scripts.isJobInList">
        function <span class="apidocSignatureSpan">bull.scripts.</span>isJobInList
        <span class="apidocSignatureSpan">(client, listKey, jobId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isJobInList = function (client, listKey, jobId){
  return execScript(client, &#x27;isJobInList&#x27;, this._isJobInList(), 1, listKey, jobId).then(function(result){
    return result === 1;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.queue.client
  .sismember(this.queue.toKey(list), this.jobId).then(function(isMember){
    return isMember === 1;
  });
};

Job.prototype._isInList = function(list) {
return scripts.<span class="apidocCodeKeywordSpan">isJobInList</span>(this.queue.client, this.queue.toKey(list), this.jobId);
};

Job.prototype._moveToSet = function(set, context){
var queue = this.queue;
var jobId = this.jobId;

return scripts.moveToSet(queue, set, jobId, context);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.move" id="apidoc.element.bull.scripts.move">
        function <span class="apidocSignatureSpan">bull.scripts.</span>move
        <span class="apidocSignatureSpan">(job, src, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">move = function (job, src, target){
  // TODO: Depending on the source we should use LREM, SREM or ZREM.
  // TODO: Depending on the target we should use LPUSH, SADD, etc.
  var keys = _.map([
    src,
    target,
    job.jobId
    ], function(name){
      return job.queue.toKey(name);
    }
  );

  var deleteJob = &#x27;redis.call(&#x22;DEL&#x22;, KEYS[3])&#x27;;

  var moveJob = [
    &#x27;redis.call(&#x22;SADD&#x22;, KEYS[2], ARGV[1])&#x27;,
    &#x27;redis.call(&#x22;HSET&#x22;, KEYS[3], &#x22;returnvalue&#x22;, ARGV[2])&#x27;,
  ].join(&#x27;\n&#x27;);

  var script = [
    &#x27;if redis.call(&#x22;EXISTS&#x22;, KEYS[3]) == 1 then&#x27;, // Make sure job exists
    &#x27; redis.call(&#x22;LREM&#x22;, KEYS[1], -1, ARGV[1])&#x27;,
    target ? moveJob : deleteJob,
    &#x27; return 0&#x27;,
    &#x27;else&#x27;,
    &#x27; return -1&#x27;,
    &#x27;end&#x27;
  ].join(&#x27;\n&#x27;);

  var args = [
    job.queue.client,
    &#x27;move&#x27; + src + (target ? target : &#x27;&#x27;),
    script,
    keys.length,
    keys[0],
    keys[1],
    keys[2],
    job.jobId,
    job.returnvalue ? JSON.stringify(job.returnvalue) : &#x27;&#x27;
  ];

  var returnLockOrErrorCode = function(lock) {
    return lock ? execScript.apply(scripts, args) : -2;
  };
  var throwUnexpectedErrors = function(err) {
    if (!(err instanceof Redlock.LockError)) {
      throw err;
    }
  };

  return job.takeLock(!!job.lock)
  .then(returnLockOrErrorCode, throwUnexpectedErrors)
  .then(function(result){
    switch (result){
      case -1:
        if(src){
          throw new Error(&#x27;Missing Job &#x27; + job.jobId + &#x27; when trying to move from &#x27; + src + &#x27; to &#x27; + target);
        } else {
          throw new Error(&#x27;Missing Job &#x27; + job.jobId + &#x27; when trying to remove it from &#x27; + src);
        }
      case -2:
        throw new Error(&#x27;Cannot get lock for job &#x27; + job.jobId + &#x27; when trying to move from &#x27; + src);
      default:
        return job.releaseLock()
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Job.prototype.move = function(src, target, returnValue){
  if(target === &#x27;completed&#x27;){
    this.returnvalue = returnValue || 0;
    if(this.opts.removeOnComplete){
      target = void 0;
    }
  }
  return scripts.<span class="apidocCodeKeywordSpan">move</span>(this, src, target);
}

Job.prototype.discard = function(){
  this._discarded = true;
}

Job.prototype.moveToFailed = function(err){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.moveToCompleted" id="apidoc.element.bull.scripts.moveToCompleted">
        function <span class="apidocSignatureSpan">bull.scripts.</span>moveToCompleted
        <span class="apidocSignatureSpan">(job, removeOnComplete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToCompleted = function (job, removeOnComplete){
  return scripts.move(job, &#x27;active&#x27;, removeOnComplete ? void 0 : &#x27;completed&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
return Promise.resolve(false);
};

Job.prototype.moveToCompleted = function(returnValue){
this.returnvalue = returnValue || 0;
return scripts.<span class="apidocCodeKeywordSpan">moveToCompleted</span>(this, this.opts.removeOnComplete);
};

Job.prototype.move = function(src, target, returnValue){
if(target === &#x27;completed&#x27;){
  this.returnvalue = returnValue || 0;
  if(this.opts.removeOnComplete){
    target = void 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.moveToSet" id="apidoc.element.bull.scripts.moveToSet">
        function <span class="apidocSignatureSpan">bull.scripts.</span>moveToSet
        <span class="apidocSignatureSpan">(queue, set, jobId, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveToSet = function (queue, set, jobId, context){
  //
  // Bake in the job id first 12 bits into the timestamp
  // to guarantee correct execution order of delayed jobs
  // (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)
  //
  // WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail
  //
  context = _.isUndefined(context) ? 0 : context;

  if(set === &#x27;delayed&#x27;) {
    context = +context || 0;
    context = context &#x3c; 0 ? 0 : context;
    if(context &#x3e; 0){
      context = context * 0x1000 + (jobId &#x26; 0xfff);
    }
  }

  var keys = _.map([
    &#x27;active&#x27;,
    set,
    jobId
    ], function(name){
      return queue.toKey(name);
    }
  );

  var args = [
    queue.client,
    &#x27;moveToSet&#x27;,
    moveToSetScript,
    keys.length,
    keys[0],
    keys[1],
    keys[2],
    JSON.stringify(context),
    jobId
  ];

  return execScript.apply(scripts, args).then(function(result){
    if(result === -1){
      throw new Error(&#x27;Missing Job &#x27; + jobId + &#x27; when trying to move from active to &#x27; + set);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return scripts.isJobInList(this.queue.client, this.queue.toKey(list), this.jobId);
};

Job.prototype._moveToSet = function(set, context){
var queue = this.queue;
var jobId = this.jobId;

return scripts.<span class="apidocCodeKeywordSpan">moveToSet</span>(queue, set, jobId, context);
};

Job.prototype._getBackOff = function() {
var backoff = 0;
var delay;
if(this.opts.backoff){
  if(!isNaN(this.opts.backoff)){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.moveUnlockedJobsToWait" id="apidoc.element.bull.scripts.moveUnlockedJobsToWait">
        function <span class="apidocSignatureSpan">bull.scripts.</span>moveUnlockedJobsToWait
        <span class="apidocSignatureSpan">(queue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveUnlockedJobsToWait = function (queue){
  var script = [
    &#x27;local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])&#x27;,
    &#x27;local activeJobs = redis.call(&#x22;LRANGE&#x22;, KEYS[1], 0, -1)&#x27;,
    &#x27;local stalled = {}&#x27;,
    &#x27;local failed = {}&#x27;,
    &#x27;for _, job in ipairs(activeJobs) do&#x27;,
    &#x27; local jobKey = ARGV[2] .. job&#x27;,
    &#x27; if(redis.call(&#x22;EXISTS&#x22;, jobKey .. &#x22;:lock&#x22;) == 0) then&#x27;,
    //  Remove from the active queue.
    &#x27;   redis.call(&#x22;LREM&#x22;, KEYS[1], 1, job)&#x27;,
    &#x27;   local lockAcquired = redis.call(&#x22;HGET&#x22;, jobKey, &#x22;lockAcquired&#x22;)&#x27;,
    &#x27;   if(lockAcquired) then&#x27;,
    //    If it was previously locked then we consider it &#x27;stalled&#x27; (Case A above). If this job
    //    has been stalled too many times, such as if it crashes the worker, then fail it.
    &#x27;     local stalledCount = redis.call(&#x22;HINCRBY&#x22;, jobKey, &#x22;stalledCounter&#x22;, 1)&#x27;,
    &#x27;     if(stalledCount &#x3e; MAX_STALLED_JOB_COUNT) then&#x27;,
    &#x27;       redis.call(&#x22;SADD&#x22;, KEYS[3], job)&#x27;,
    &#x27;       redis.call(&#x22;HSET&#x22;, jobKey, &#x22;failedReason&#x22;, &#x22;job stalled more than allowable limit&#x22;)&#x27;,
    &#x27;       table.insert(failed, job)&#x27;,
    &#x27;     else&#x27;,
    //      Move the job back to the wait queue, to immediately be picked up by a waiting worker.
    &#x27;       redis.call(&#x22;RPUSH&#x22;, KEYS[2], job)&#x27;,
    &#x27;       table.insert(stalled, job)&#x27;,
    &#x27;     end&#x27;,
    &#x27;   else&#x27;,
    //    Move the job back to the wait queue, to immediately be picked up by a waiting worker.
    &#x27;     redis.call(&#x22;RPUSH&#x22;, KEYS[2], job)&#x27;,
    &#x27;   end&#x27;,
    &#x27; end&#x27;,
    &#x27;end&#x27;,
    &#x27;return {failed, stalled}&#x27;
  ].join(&#x27;\n&#x27;);

  var args = [
    queue.client,
    &#x27;moveUnlockedJobsToWait&#x27;,
    script,
    3,
    queue.toKey(&#x27;active&#x27;),
    queue.toKey(&#x27;wait&#x27;),
    queue.toKey(&#x27;failed&#x27;),
    queue.MAX_STALLED_JOB_COUNT,
    queue.toKey(&#x27;&#x27;)
  ];

  return execScript.apply(scripts, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// the index is reversed to the actual priority number (0 is &#x27;critical&#x27;)
// so flip it to get the correct &#x22;priority index&#x22;
var nbJobsToProcess = _this.strategy(PriorityQueue.priorities.critical - index);
var i = 0;

var fn = function() {
  return queue.<span class="apidocCodeKeywordSpan">moveUnlockedJobsToWait</span>().then(queue.getNextJob.bind(queue, {
      block: false
    }))
    .then(function(job) {
      if (job) {
        emptyLoop = false;
        return queue.processJob(job).then(function() {
          if (++i &#x3c; nbJobsToProcess &#x26;&#x26; !_this.paused) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.releaseLock" id="apidoc.element.bull.scripts.releaseLock">
        function <span class="apidocSignatureSpan">bull.scripts.</span>releaseLock
        <span class="apidocSignatureSpan">(job)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">releaseLock = function (job){
  var lock = job.lock;
  if (!lock) {
    throw new Error(&#x27;Unable to release nonexisting lock&#x27;);
  }
  return lock.unlock()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
Releases the lock. Only locks owned by the queue instance can be released.
*/
Job.prototype.releaseLock = function(){
var _this = this;
return scripts.<span class="apidocCodeKeywordSpan">releaseLock</span>(this)
.then(function() { _this.lock = null; });
};

Job.prototype.delayIfNeeded = function(){
if(this.delay){
  var jobDelayedTimestamp = this.timestamp + this.delay;
  if(jobDelayedTimestamp &#x3e; Date.now()){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.remove" id="apidoc.element.bull.scripts.remove">
        function <span class="apidocSignatureSpan">bull.scripts.</span>remove
        <span class="apidocSignatureSpan">(queue, jobId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (queue, jobId){
  var script = [
    &#x27;redis.call(&#x22;LREM&#x22;, KEYS[1], 0, ARGV[1])&#x27;,
    &#x27;redis.call(&#x22;LREM&#x22;, KEYS[2], 0, ARGV[1])&#x27;,
    &#x27;redis.call(&#x22;ZREM&#x22;, KEYS[3], ARGV[1])&#x27;,
    &#x27;redis.call(&#x22;LREM&#x22;, KEYS[4], 0, ARGV[1])&#x27;,
    &#x27;redis.call(&#x22;SREM&#x22;, KEYS[5], ARGV[1])&#x27;,
    &#x27;redis.call(&#x22;SREM&#x22;, KEYS[6], ARGV[1])&#x27;,
    &#x27;redis.call(&#x22;DEL&#x22;, KEYS[7])&#x27;].join(&#x27;\n&#x27;);

  var keys = _.map([
    &#x27;active&#x27;,
    &#x27;wait&#x27;,
    &#x27;delayed&#x27;,
    &#x27;paused&#x27;,
    &#x27;completed&#x27;,
    &#x27;failed&#x27;,
    jobId], function(name){
      return queue.toKey(name);
    }
  );

  var args = [
    queue.client,
    &#x27;remove&#x27;,
    script,
    keys.length,
    keys[0],
    keys[1],
    keys[2],
    keys[3],
    keys[4],
    keys[5],
    keys[6],
    jobId
  ];

  return execScript.apply(scripts, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return _this.moveToDelayed(Date.now() + backoff);
      }else{
        // If not, retry immediately
        return _this._retryAtOnce();
      }
    } else if(_this.opts.removeOnFail){
      return _this.releaseLock().then(function(){
        return _this.<span class="apidocCodeKeywordSpan">remove</span>();
      });
    }
    // If not, move to failed
    return _this._moveToSet(&#x27;failed&#x27;);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.reprocessJob" id="apidoc.element.bull.scripts.reprocessJob">
        function <span class="apidocSignatureSpan">bull.scripts.</span>reprocessJob
        <span class="apidocSignatureSpan">(job, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reprocessJob = function (job, options) {
  var push = (job.opts.lifo ? &#x27;R&#x27; : &#x27;L&#x27;) + &#x27;PUSH&#x27;;

  var script = [
    &#x27;if (redis.call(&#x22;EXISTS&#x22;, KEYS[1]) == 1) then&#x27;,
    &#x27;  if (redis.call(&#x22;EXISTS&#x22;, KEYS[2]) == 0) then&#x27;,
    &#x27;    if (redis.call(&#x22;SREM&#x22;, KEYS[3], ARGV[1]) == 1) then&#x27;,
    &#x27;      redis.call(&#x22;&#x27; + push + &#x27;&#x22;, KEYS[4], ARGV[1])&#x27;,
    &#x27;      redis.call(&#x22;PUBLISH&#x22;, KEYS[5], ARGV[1])&#x27;,
    &#x27;      return 1&#x27;,
    &#x27;    else&#x27;,
    &#x27;      return -2&#x27;,
    &#x27;    end&#x27;,
    &#x27;  else&#x27;,
    &#x27;    return -1&#x27;,
    &#x27;  end&#x27;,
    &#x27;else&#x27;,
    &#x27;  return 0&#x27;,
    &#x27;end&#x27;
  ].join(&#x27;\n&#x27;);

  var queue = job.queue;

  var keys = [
    queue.toKey(job.jobId),
    queue.toKey(job.jobId) + &#x27;:lock&#x27;,
    queue.toKey(options.state),
    queue.toKey(&#x27;wait&#x27;),
    queue.toKey(&#x27;jobs&#x27;)
  ];

  var args = [
    queue.client,
    &#x27;retryJob&#x27;,
    script,
    5,
    keys[0],
    keys[1],
    keys[2],
    keys[3],
    keys[4],
    job.jobId
  ];

  return execScript.apply(scripts, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Promise} If resolved and return code is 1, then the queue emits a waiting event
 * otherwise the operation was not a success and throw the corresponding error. If the promise
 * rejects, it indicates that the script failed to execute
 */
Job.prototype.retry = function(){
var queue = this.queue;
var _this = this;
return scripts.<span class="apidocCodeKeywordSpan">reprocessJob</span>(this, { state: &#x27;failed&#x27; }).then(function(result
) {
  if (result === 1) {
    queue.emit(&#x27;waiting&#x27;, _this);
  } else if (result === 0) {
    throw new Error(&#x27;Couldn\&#x27;t retry job: The job doesn\&#x27;t exist&#x27;);
  } else if (result === -1) {
    throw new Error(&#x27;Couldn\&#x27;t retry job: The job is locked&#x27;);
  } else if (result === -2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.takeLock" id="apidoc.element.bull.scripts.takeLock">
        function <span class="apidocSignatureSpan">bull.scripts.</span>takeLock
        <span class="apidocSignatureSpan">(queue, job, renew, ensureActive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeLock = function (queue, job, renew, ensureActive){
  var lock = job.lock;
  if (renew &#x26;&#x26; !lock) {
    throw new Error(&#x27;Unable to renew nonexisting lock&#x27;);
  }
  if (renew) {
    return lock.extend(queue.LOCK_DURATION);
  }
  if (lock) {
    return Promise.resolve(lock);
  }

  var redlock;
  if (ensureActive) {
    var isJobInList = this._isJobInList(&#x27;KEYS[2]&#x27;, &#x27;ARGV[3]&#x27;, &#x27;if&#x27;);
    var lockAcquired = [&#x27;and redis.call(&#x22;HSET&#x22;, KEYS[3], &#x22;lockAcquired&#x22;, &#x22;1&#x22;)&#x27;].join(&#x27;&#x27;);
    var success = &#x27;then return 1 else return 0 end&#x27;;
    var opts = {
      lockScript: function(lockScript) {
        return [
          isJobInList,
          lockScript.replace(&#x27;return&#x27;, &#x27;and&#x27;),
          lockAcquired,
          success
        ].join(&#x27;\n&#x27;);
      },
      extraLockKeys: [job.queue.toKey(&#x27;active&#x27;), queue.toKey(job.jobId)],
      extraLockArgs: [job.jobId]
    };
    redlock = new Redlock(queue.clients, _.extend(opts, queue.redlock));
  } else {
    redlock = new Redlock(queue.clients, queue.redlock);
  }

  return redlock.lock(job.lockKey(), queue.LOCK_DURATION).catch(function(err){
    //
    // Failing to lock due to already locked is not an error.
    //
    if(err.name != &#x27;LockError&#x27;){
      throw err;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
  Takes a lock for this job so that no other queue worker can process it at the
  same time.
*/
Job.prototype.takeLock = function(renew, ensureActive){
  var _this = this;
  return scripts.<span class="apidocCodeKeywordSpan">takeLock</span>(this.queue, this, renew, ensureActive).then(function(lock) {
    if (lock){
      _this.lock = lock;
    }
    return lock || false;
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.scripts.updateDelaySet" id="apidoc.element.bull.scripts.updateDelaySet">
        function <span class="apidocSignatureSpan">bull.scripts.</span>updateDelaySet
        <span class="apidocSignatureSpan">(queue, delayedTimestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateDelaySet = function (queue, delayedTimestamp){
  var script = [
    &#x27;local RESULT = redis.call(&#x22;ZRANGE&#x22;, KEYS[1], 0, 0, &#x22;WITHSCORES&#x22;)&#x27;,
    &#x27;local jobId = RESULT[1]&#x27;,
    &#x27;local score = RESULT[2]&#x27;,
    &#x27;if (score ~= nil) then&#x27;,
    &#x27; score = score / 0x1000 &#x27;,
    &#x27; if (score &#x3c;= tonumber(ARGV[2])) then&#x27;,
    &#x27;  redis.call(&#x22;ZREM&#x22;, KEYS[1], jobId)&#x27;,
    &#x27;  redis.call(&#x22;LREM&#x22;, KEYS[2], 0, jobId)&#x27;,
    &#x27;  redis.call(&#x22;LPUSH&#x22;, KEYS[3], jobId)&#x27;,
    &#x27;  redis.call(&#x22;PUBLISH&#x22;, KEYS[4], jobId)&#x27;,
    &#x27;  redis.call(&#x22;HSET&#x22;, ARGV[1] .. jobId, &#x22;delay&#x22;, 0)&#x27;,
    &#x27;  local nextTimestamp = redis.call(&#x22;ZRANGE&#x22;, KEYS[1], 0, 0, &#x22;WITHSCORES&#x22;)[2]&#x27;,
    &#x27;  if(nextTimestamp ~= nil) then&#x27;,
    &#x27;   nextTimestamp = nextTimestamp / 0x1000&#x27;,
    &#x27;   redis.call(&#x22;PUBLISH&#x22;, KEYS[1], nextTimestamp)&#x27;,
    &#x27;  end&#x27;,
    &#x27;  return nextTimestamp&#x27;,
    &#x27; end&#x27;,
    &#x27; return score&#x27;,
    &#x27;end&#x27;].join(&#x27;\n&#x27;);

  var keys = _.map([
    &#x27;delayed&#x27;,
    &#x27;active&#x27;,
    &#x27;wait&#x27;,
    &#x27;jobs&#x27;], function(name){
      return queue.toKey(name);
  });

  var args = [
    queue.client,
    &#x27;updateDelaySet&#x27;,
    script,
    keys.length,
    keys[0],
    keys[1],
    keys[2],
    keys[3],
    queue.toKey(&#x27;&#x27;),
    delayedTimestamp
  ];

  return execScript.apply(scripts, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.super_" id="apidoc.module.bull.super_">module bull.super_</a></h1>


    <h2>
        <a href="#apidoc.element.bull.super_.super_" id="apidoc.element.bull.super_.super_">
        function <span class="apidocSignatureSpan">bull.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.super_.prototype" id="apidoc.module.bull.super_.prototype">module bull.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bull.super_.prototype.distEmit" id="apidoc.element.bull.super_.prototype.distEmit">
        function <span class="apidocSignatureSpan">bull.super_.prototype.</span>distEmit
        <span class="apidocSignatureSpan">(evt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distEmit = function (evt) {
  var _this = this;
  var args = Array.prototype.slice.call(arguments);
  this.emit.apply(this, args);

  args[0] = this.uuid;

  // Emit to other nodes
  return new Promise(function (resolve, reject) {
    _this.pubClient.publish(evt, JSON.stringify(args), function (err) {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Job.create = function(queue, data, opts){
var job = new Job(queue, data, opts);

return addJob(queue, job).then(function(jobId){
  job.jobId = jobId;
  queue.<span class="apidocCodeKeywordSpan">distEmit</span>(&#x27;waiting&#x27;, job.toJSON());
  debuglog(&#x27;Job added&#x27;, jobId);
  return job;
});
};

Job.fromId = function(queue, jobId){
// jobId can be undefined if moveJob returns undefined
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.super_.prototype.off" id="apidoc.element.bull.super_.prototype.off">
        function <span class="apidocSignatureSpan">bull.super_.prototype.</span>off
        <span class="apidocSignatureSpan">(evt, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (evt, listener) {
  var _this = this;
  var args = Array.prototype.slice.call(arguments);
  EventEmitter.prototype.removeListener.apply(this, args);

  // TODO: we should take into consideration isGlobal.
  if (!_this.listenerCount(evt)) {
    _this.subClient.unsubscribe(evt);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.super_.prototype.on" id="apidoc.element.bull.super_.prototype.on">
        function <span class="apidocSignatureSpan">bull.super_.prototype.</span>on
        <span class="apidocSignatureSpan">(evt, listener, isGlobal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (evt, listener, isGlobal) {
  var _this = this;
  var args = Array.prototype.slice.call(arguments);
  EventEmitter.prototype.on.apply(this, args);

  if (isGlobal) {
    return new Promise(function (resolve, reject) {
      _this.subClient.subscribe(args[0], function (err) {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    })
  }
  return Promise.resolve(void 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
queue.resume().then(function(){
  // queue is resumed now
})
```

A queue emits also some useful events:
```javascript
.<span class="apidocCodeKeywordSpan">on</span>(&#x27;ready&#x27;, function() {
  // Queue ready for job
  // All Redis connections are done
})
.on(&#x27;error&#x27;, function(error) {
  // Error
})
.on(&#x27;active&#x27;, function(job, jobPromise){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.super_.prototype.removeListener" id="apidoc.element.bull.super_.prototype.removeListener">
        function <span class="apidocSignatureSpan">bull.super_.prototype.</span>removeListener
        <span class="apidocSignatureSpan">(evt, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function (evt, listener) {
  var _this = this;
  var args = Array.prototype.slice.call(arguments);
  EventEmitter.prototype.removeListener.apply(this, args);

  // TODO: we should take into consideration isGlobal.
  if (!_this.listenerCount(evt)) {
    _this.subClient.unsubscribe(evt);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    reject(err);
    removeListeners();
    clearInterval(interval);
  }
}

function removeListeners(){
  _this.queue.<span class="apidocCodeKeywordSpan">removeListener</span>(&#x27;completed&#x27;, onCompleted);
  _this.queue.removeListener(&#x27;failed&#x27;, onFailed);
}

_this.queue.on(&#x27;completed&#x27;, onCompleted);
_this.queue.on(&#x27;failed&#x27;, onFailed);

//
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.timer_manager" id="apidoc.module.bull.timer_manager">module bull.timer_manager</a></h1>


    <h2>
        <a href="#apidoc.element.bull.timer_manager.timer_manager" id="apidoc.element.bull.timer_manager.timer_manager">
        function <span class="apidocSignatureSpan">bull.</span>timer_manager
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimerManager(){
  this.idle = true;
  this.listeners = [];
  this.timers = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bull.timer_manager.prototype" id="apidoc.module.bull.timer_manager.prototype">module bull.timer_manager.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bull.timer_manager.prototype.clear" id="apidoc.element.bull.timer_manager.prototype.clear">
        function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>clear
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (id){
  var timers = this.timers;
  var timer = timers[id];
  if(!timer) {
    return;
  }
  clearTimeout(timer.timer);
  delete timers[id];
  if(!this.idle &#x26;&#x26; (_.size(timers) === 0)){
    while(this.listeners.length){
      this.listeners.pop()();
    }
    this.idle = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
@param {Function} fn - Function to execute after delay
@returns {Number} id - The timer id. Used to clear the timer
*/
TimerManager.prototype.set = function(name, delay, fn){
var id = uuid.v4();
var now = Date.now();
var timer = setTimeout(function (timerInstance, timeoutId) {
  timerInstance.<span class="apidocCodeKeywordSpan">clear</span>(timeoutId);
  try{
    fn();
  }catch(err){
    console.error(err);
  }
}, delay, this, id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.timer_manager.prototype.clearAll" id="apidoc.element.bull.timer_manager.prototype.clearAll">
        function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>clearAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearAll = function (){
  var _this = this;
  _.each(this.timers, function(timer, id){
    _this.clear(id);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.timer_manager.prototype.set" id="apidoc.element.bull.timer_manager.prototype.set">
        function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>set
        <span class="apidocSignatureSpan">(name, delay, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (name, delay, fn){
  var id = uuid.v4();
  var now = Date.now();
  var timer = setTimeout(function (timerInstance, timeoutId) {
    timerInstance.clear(timeoutId);
    try{
      fn();
    }catch(err){
      console.error(err);
    }
  }, delay, this, id);

  // XXX only the timer is used, but the
  // other fields are useful for
  // troubleshooting/debugging
  this.timers[id] = {
    name: name,
    created: now,
    timer: timer
  };

  this.idle = false;
  return id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bull.timer_manager.prototype.whenIdle" id="apidoc.element.bull.timer_manager.prototype.whenIdle">
        function <span class="apidocSignatureSpan">bull.timer_manager.prototype.</span>whenIdle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whenIdle = function () {
  var _this = this;
  return new Promise(function(resolve){
    if(_this.idle) {
      resolve();
    } else{
      _this.listeners.unshift(resolve);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
